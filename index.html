<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bitcoin DCA Calculator (CAD)</title>
  <style>
    :root{--bg:#0b1020;--panel:#141a2e;--line:#2a3458;--text:#ecf0ff;--muted:#a6b2d1;--ok:#22c55e;--warn:#f59e0b;--accent:#f7931a}
body.mode-btc{--accent:#f7931a;--bg:#1a1106;--panel:#26180a;--line:#5c3a12;--muted:#e5c39b}
body.mode-bteth{--accent:#60a5fa;--bg:#0b1020;--panel:#141a2e;--line:#2a3458;--muted:#a6b2d1}
    *{box-sizing:border-box} body{margin:0;font-family:Inter,system-ui,sans-serif;background:var(--bg);color:var(--text)}
    .wrap{max-width:1080px;margin:0 auto;padding:18px} .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:14px;margin-bottom:12px}
    h1{margin:0 0 8px} .sub{color:var(--muted);margin:0 0 12px} label{display:block;color:var(--muted);margin:6px 0 4px}
    input,button,select{width:100%;padding:10px;border-radius:10px;border:1px solid #3a4670;background:#0f1630;color:var(--text)}
    button{background:#22305c;cursor:pointer;font-weight:700} .grid{display:grid;gap:10px}
    h1{color:var(--accent)}
    .g6{grid-template-columns:repeat(6,1fr)} .g5{grid-template-columns:repeat(5,1fr)} .g4{grid-template-columns:repeat(4,1fr)} .g3{grid-template-columns:repeat(3,1fr)}
    .list{display:grid;gap:8px}.item{background:#0f1630;border:1px solid #3a4670;border-radius:10px;padding:8px}
    .cards{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}.card{background:#0f1630;border:1px solid #3a4670;border-radius:10px;padding:10px}
    .small{font-size:.9rem;color:var(--muted)} .ok{color:var(--ok)} .warn{color:var(--warn)} .actions{display:flex;gap:8px;flex-wrap:wrap}.actions button{width:auto}
    .dateWrap{display:flex;gap:6px}.dateWrap input{flex:1}.dateWrap button{width:auto;padding:8px 10px}
    table{width:100%;border-collapse:collapse} th,td{border-bottom:1px solid #33406a;padding:8px;text-align:left}
    .hero{display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap}
    .pill{display:inline-block;padding:4px 8px;border:1px solid #3a4670;border-radius:999px;background:#0f1630;color:#b7c3e4;font-size:.8rem}
    .chip{width:auto;padding:6px 10px;font-size:.85rem;border-radius:999px}
    dialog{border:1px solid #3a4670;background:#0f1630;color:#ecf0ff;border-radius:12px;max-width:760px;width:min(92vw,760px)}
    dialog::backdrop{background:rgba(0,0,0,.55)}
    @media(max-width:980px){.g5,.g4,.g3,.cards{grid-template-columns:1fr 1fr}}
  </style>
</head>
<body>
<div class="wrap">
  <div class="hero">
    <div>
      <h1 id="appTitle" style="margin:0;">Bitcoin DCA Calculator (CAD)</h1>
      <p class="sub" style="margin:6px 0 8px;">DCA = <b>Dollar-Cost Averaging</b> (aka recurring buys over time). Track recurring buys, dip buys, and estimated returns in CAD. Toggle BTC-only vs BTC+ETH at top.</p>
      <span class="pill">Not financial/tax advice</span>
    </div>
    <div class="actions">
      <label class="small" style="display:flex;align-items:center;gap:6px"><input type="radio" name="assetMode" value="btc" checked> Bitcoin-Only Mode</label>
      <label class="small" style="display:flex;align-items:center;gap:6px"><input type="radio" name="assetMode" value="bteth"> BTC + ETH Mode</label>
      <label class="small" style="display:flex;align-items:center;gap:6px"><input type="radio" name="quoteMode" value="CAD" checked> CAD</label>
      <label class="small" style="display:flex;align-items:center;gap:6px"><input type="radio" name="quoteMode" value="USD"> USD</label>
      <button id="helpBtn" type="button">Help</button>
      <button id="demoBtn" type="button">Load Demo Data</button>
      <button id="clearAll" type="button" style="background:#5b1f2a;border-color:#7a2a39;">Clear All</button>
    </div>
  </div>

  <section class="panel">
    <h2>Shakepay Import (recommended first step)</h2>
    <p class="small">If you use Shakepay, upload <code>crypto_transactions_summary.csv</code> first to save time. Asset mode controls whether BTC-only rows or BTC+ETH rows are included in analysis. If you do not use Shakepay, enter your information manually below. Data is processed in-browser and saved only to this browser profile.</p>
    <div class="grid g3">
      <div><label>Shakepay CSV</label><input id="shakepayFile" type="file" accept=".csv,text/csv"></div>
      <div><label>&nbsp;</label><button id="analyzeShakepay" type="button">Analyze Shakepay</button></div>
      <div></div>
    </div>
    <div id="shakepayResult" style="margin-top:10px"></div>
  </section>
  <section class="panel">
    <h2>DCA / Auto-Buy Rules (selected currency)</h2>
    <div class="grid g6">
      <div>
        <label>Start Date</label>
        <div class="dateWrap"><input id="rDate" type="date" value="2021-10-31"><button id="pickRDate" type="button">ðŸ“…</button></div>
      </div>
      <div><label>Amount (CAD)</label><input id="rAmt" type="number" min="0" step="0.01" value="15"></div>
      <div><label>Frequency</label><select id="rFreq"><option value="daily">Daily</option><option value="weekly">Weekly</option><option value="biweekly">Bi-weekly</option><option value="monthly">Monthly</option></select></div>
      <div id="rAssetWrap"><label>Asset</label><select id="rAsset"><option value="BTC">BTC</option><option value="ETH">ETH</option></select></div>
      <div><label>&nbsp;</label><button id="addRule">Add / Update Rule</button></div>
      <div><label>&nbsp;</label><button id="clearRules">Clear Rules</button></div>
    </div>
    <div class="actions" style="margin-top:10px">
      <button id="normalizeRules" type="button">Normalize Rules (remove duplicates)</button>
    </div>
    <div id="ruleList" class="list" style="margin-top:10px"></div>
  </section>

  <section class="panel">
    <h2>Dip Buys (CAD)</h2>
    <p class="small">Optional override fields let you use your books exactly (price + BTC or sats).</p>
    <div class="grid g5">
      <div>
        <label>Date</label>
        <div class="dateWrap"><input id="dDate" type="date"><button id="pickDDate" type="button">ðŸ“…</button></div>
      </div>
      <div><label>Amount Paid (CAD)</label><input id="dAmt" type="number" min="0" step="0.01" placeholder="1000"></div>
      <div><label>Book Price (selected currency per unit, optional)</label><input id="dPrice" type="number" min="0" step="0.01" placeholder="90000"></div>
      <div><label>Received Amount (optional)</label><input id="dQty" type="number" min="0" step="0.00000001" placeholder="0.01111112"></div>
      <div><label>Received Unit</label><select id="dQtyUnit"><option value="btc">BTC</option><option value="sats">sats</option><option value="eth">ETH</option></select></div>
    </div>
    <div class="actions" style="margin-top:10px">
      <button id="addDip">Add Dip Buy</button>
      <button id="saveDipEdit" style="display:none;">Save Dip Edit</button>
      <button id="cancelDipEdit" style="display:none;">Cancel Edit</button>
      <button id="clearDips">Clear Dip Buys</button>
    </div>
    <div class="grid g3" style="margin-top:10px">
      <div><label>Min CAD for dip extraction</label><input id="dipMinCad" type="number" min="0" step="1" value="250"></div>
      <div><label><input id="replaceDipsOnExtract" type="checkbox" checked> Replace existing dips when extracting</label></div>
      <div><label>&nbsp;</label><button id="extractDipsFromShakepay" type="button">Extract Dips from Uploaded Shakepay CSV</button></div>
    </div>
    <div class="actions" style="margin-top:10px">
      <span class="small">Sort dips:</span>
      <button id="sortDipDate" class="chip" type="button">Date</button>
      <button id="sortDipBestRoi" class="chip" type="button">Best ROI</button>
      <button id="sortDipWorstRoi" class="chip" type="button">Worst ROI</button>
      <button id="sortDipBiggestPnl" class="chip" type="button">Best PnL</button>
      <button id="sortDipWorstPnl" class="chip" type="button">Worst PnL</button>
    </div>
    <div id="dipList" class="list" style="margin-top:10px"></div>
  </section>

  <section class="panel">
    <h2>Returns Calculator</h2>
    <div class="grid g3">
      <div><label>Price source</label><input value="CryptoCompare historical daily" disabled></div>
      <div><label>FX (CAD per USD, used for CADâ†”USD conversion)</label><input id="fx" type="number" min="0.5" step="0.0001" value="1.35"></div>
      <div><label>&nbsp;</label><button id="calc">Update Calculated Returns</button></div>
    </div>
    <div class="grid g3" style="margin-top:10px">
      <div>
        <label>Calculation Mode</label>
        <select id="calcMode">
          <option value="rules">Rules only</option>
          <option value="shakepay" selected>Shakepay only</option>
          <option value="hybrid">Hybrid (advanced)</option>
        </select>
      </div>
      <div><label>&nbsp;</label><span class="small">Rules only = DCA+Dip rules. Shakepay only = imported buys only. Hybrid = both (may overlap).</span></div>
      <div></div>
    </div>
    <p id="status" class="small" style="margin-top:10px">Ready.</p>
    <div id="result" style="margin-top:10px"></div>
  </section>


  <section class="panel">
    <h2>Asset Flow Summary (Shakepay CSV)</h2>
    <p class="small">Visibility only: buys, rewards, received, sent, and net flow from imported Shakepay rows (based on selected asset mode).</p>
    <div id="flowResult"></div>
  </section>

</div>

<dialog id="helpDialog">
  <h3>Quick Guide</h3>
  <ol>
    <li><b>If you use Shakepay</b>, upload your summary first (it can auto-detect DCA rules and import only larger buys as dips).</li>
    <li><b>Add/Edit DCA rules</b>: each rule sets the total daily CAD amount from that date onward.</li>
    <li><b>Add/Edit dip buys</b> (optional): use market price, book price, or exact BTC/sats received.</li>
    <li><b>Calculate Returns</b> to fetch history and estimate BTC, value, and ROI.</li>
  </ol>
  <p class="small">Privacy: your data is stored in your browser (localStorage). Use <b>Clear All</b> to wipe it.</p>
  <div class="actions"><button id="closeHelp" type="button">Close</button></div>
</dialog>

<script>
const SATS = 100000000;
const defaultRules = [];
const jget = (k, fallback) => {
  try {
    const v = JSON.parse(localStorage.getItem(k) || 'null');
    return v ?? fallback;
  } catch {
    return fallback;
  }
};

const rules = (jget('btc.rules', structuredClone(defaultRules)) || [])
  .filter(r => r && typeof r === 'object')
  .map(r => ({date: String(r.date || '').slice(0,10), amount: Number(r.amount||0), freq: String(r.freq||'daily'), asset: String(r.asset||'BTC').toUpperCase()}))
  .filter(r => r.date && r.amount > 0 && (r.asset==='BTC' || r.asset==='ETH'));
const dips = (jget('btc.dips', []) || [])
  .filter(d => d && typeof d === 'object')
  .map(d => ({date: String(d.date || '').slice(0,10), amount: Number(d.amount||0), price: d.price==null?null:Number(d.price), asset: String(d.asset||'BTC').toUpperCase(), btc: d.btc==null?null:Number(d.btc), eth: d.eth==null?null:Number(d.eth), sats: d.sats==null?null:Number(d.sats)}))
  .filter(d => d.date && d.amount > 0);
const shakepayBuyLots = (jget('btc.shakepayBuyLots', []) || [])
  .filter(l => l && typeof l === 'object')
  .map(l => ({date: String(l.date || '').slice(0,10), amount: Number(l.amount||0), ccy: String(l.ccy||'CAD').toUpperCase(), btc: Number(l.btc||0), asset: String(l.asset||'BTC').toUpperCase(), price: l.price==null?null:Number(l.price)}))
  .filter(l => l.date && l.amount > 0);
let editingDipIndex = null;
let dipSortMode = 'date';

const $ = id => document.getElementById(id);
const fmt = n => Number(n).toLocaleString(undefined,{maximumFractionDigits:2});
const dayKey = d => new Date(d).toISOString().slice(0,10);
const dateObj = ymd => new Date(ymd+'T00:00:00');
const save = () => { localStorage.setItem('btc.rules', JSON.stringify(rules)); localStorage.setItem('btc.dips', JSON.stringify(dips)); };
const convertAmount = (amount, from, to, fxCadPerUsd) => {
  if (from === to) return Number(amount);
  if (from === 'CAD' && to === 'USD') return Number(amount) / fxCadPerUsd;
  if (from === 'USD' && to === 'CAD') return Number(amount) * fxCadPerUsd;
  return Number(amount);
};
const esc = (s='') => String(s)
  .replace(/&/g,'&amp;')
  .replace(/</g,'&lt;')
  .replace(/>/g,'&gt;')
  .replace(/"/g,'&quot;')
  .replace(/'/g,'&#39;');

function openPicker(input){ if (input.showPicker) input.showPicker(); else input.focus(); }
function getAssetMode(){
  return (document.querySelector('input[name="assetMode"]:checked') || {}).value || 'btc';
}
function getQuoteMode(){
  return (document.querySelector('input[name="quoteMode"]:checked') || {}).value || 'CAD';
}
function applyMode(){
  const mode = getAssetMode();
  const quote = getQuoteMode();
  document.body.classList.remove('mode-btc','mode-bteth');
  const bteth = mode === 'bteth';
  document.body.classList.add(bteth ? 'mode-bteth' : 'mode-btc');
  $('appTitle').textContent = bteth ? `Bitcoin/ETH DCA Calculator (${quote})` : `Bitcoin DCA Calculator (${quote})`;
  $('rAssetWrap').style.display = bteth ? '' : 'none';
  if (!bteth) $('rAsset').value = 'BTC';
}
const savedMode = localStorage.getItem('btc.assetMode') || 'btc';
const savedQuote = localStorage.getItem('btc.quoteMode') || 'CAD';
(document.querySelector(`input[name="assetMode"][value="${savedMode}"]`) || document.querySelector('input[name="assetMode"][value="btc"]')).checked = true;
(document.querySelector(`input[name="quoteMode"][value="${savedQuote}"]`) || document.querySelector('input[name="quoteMode"][value="CAD"]')).checked = true;
applyMode();
document.querySelectorAll('input[name="assetMode"]').forEach(el=>el.addEventListener('change', ()=>{ localStorage.setItem('btc.assetMode', getAssetMode()); applyMode(); }));
document.querySelectorAll('input[name="quoteMode"]').forEach(el=>el.addEventListener('change', ()=>{ localStorage.setItem('btc.quoteMode', getQuoteMode()); applyMode(); }));

$('pickRDate').onclick = () => openPicker($('rDate'));
$('pickDDate').onclick = () => openPicker($('dDate'));
$('sortDipDate').onclick = () => { dipSortMode = 'date'; render(); };
$('sortDipBestRoi').onclick = () => { dipSortMode = 'bestRoi'; render(); };
$('sortDipWorstRoi').onclick = () => { dipSortMode = 'worstRoi'; render(); };
$('sortDipBiggestPnl').onclick = () => { dipSortMode = 'biggestPnl'; render(); };
$('sortDipWorstPnl').onclick = () => { dipSortMode = 'worstPnl'; render(); };
$('helpBtn').onclick = () => $('helpDialog').showModal();
$('closeHelp').onclick = () => $('helpDialog').close();
$('demoBtn').onclick = () => {
  rules.splice(0, rules.length, {date:'2024-01-01', amount:5}, {date:'2025-01-01', amount:10});
  dips.splice(0, dips.length, {date:'2025-08-05', amount:500, price:78000, btc:null, sats:null});
  save(); render();
  $('status').textContent = 'Loaded demo data.';
};

function render(){
  rules.sort((a,b)=>a.date.localeCompare(b.date));
  $('ruleList').innerHTML = rules.map((r,i)=>`<div class="item">From <b>${esc(r.date)}</b>: <b>$${fmt(r.amount)} / ${esc(r.freq||'daily')} / ${esc(r.asset||'BTC')}</b> <button onclick="delRule(${i})" style="width:auto;margin-left:8px">remove</button></div>`).join('') || '<p class="small">No rules.</p>';

  const lastPrice = Number(localStorage.getItem('btc.lastCurrentPriceCad') || 0);
  const lastEthPrice = Number(localStorage.getItem('btc.lastCurrentEthPriceCad') || 0);
  const metric = (d) => {
    const asset = (d.asset || 'BTC').toUpperCase();
    const qty = asset === 'ETH'
      ? (d.eth ? Number(d.eth) : (d.price ? Number(d.amount)/Number(d.price) : 0))
      : (d.btc ? Number(d.btc) : (d.sats ? Number(d.sats)/SATS : (d.price ? Number(d.amount)/Number(d.price) : 0)));
    const pNow = asset === 'ETH' ? lastEthPrice : lastPrice;
    const valNow = pNow > 0 ? qty * pNow : 0;
    const pnl = valNow - Number(d.amount || 0);
    const roi = Number(d.amount) > 0 ? (pnl / Number(d.amount)) * 100 : 0;
    return {qty, valNow, pnl, roi, asset};
  };

  if (dipSortMode === 'date') dips.sort((a,b)=>a.date.localeCompare(b.date));
  if (dipSortMode === 'bestRoi') dips.sort((a,b)=>metric(b).roi - metric(a).roi);
  if (dipSortMode === 'worstRoi') dips.sort((a,b)=>metric(a).roi - metric(b).roi);
  if (dipSortMode === 'biggestPnl') dips.sort((a,b)=>metric(b).pnl - metric(a).pnl);
  if (dipSortMode === 'worstPnl') dips.sort((a,b)=>metric(a).pnl - metric(b).pnl);

  $('dipList').innerHTML = dips.map((d,i)=>{
    const m = metric(d);
    const asset = m.asset;
    const detail = asset === 'ETH'
      ? (d.eth ? `${Number(d.eth).toFixed(8)} ETH` : (d.price ? `at $${fmt(d.price)} / ETH` : 'uses market daily avg'))
      : (d.btc ? `${Number(d.btc).toFixed(8)} BTC` : (d.sats ? `${Number(d.sats).toLocaleString()} sats` : (d.price ? `at $${fmt(d.price)} / BTC` : 'uses market daily avg')));
    let perf = '';
    if (m.qty > 0 && m.valNow > 0) {
      perf = ` <span class="small">| PnL: <b class="${m.pnl>=0?'ok':'warn'}">$${fmt(m.pnl)}</b> | ROI: <b class="${m.roi>=0?'ok':'warn'}">${m.roi.toFixed(2)}%</b></span>`;
    }
    return `<div class="item">${esc(d.date)} [${asset}]: <b>$${fmt(d.amount)}</b> â€” ${esc(detail)}${perf}<button onclick="editDip(${i})" style="width:auto;margin-left:8px">edit</button><button onclick="delDip(${i})" style="width:auto;margin-left:8px">remove</button></div>`;
  }).join('') || '<p class="small">No dip buys.</p>';
}
window.delRule = i => { rules.splice(i,1); save(); render(); };
window.delDip = i => { dips.splice(i,1); save(); render(); };
window.editDip = i => {
  const d = dips[i];
  if (!d) return;
  editingDipIndex = i;
  $('dDate').value = d.date || '';
  $('dAmt').value = d.amount ?? '';
  $('dPrice').value = d.price ?? '';
  $('dQty').value = d.eth ?? (d.btc ?? (d.sats ?? ''));
  $('dQtyUnit').value = d.eth ? 'eth' : (d.btc ? 'btc' : (d.sats ? 'sats' : 'btc'));
  $('addDip').style.display = 'none';
  $('saveDipEdit').style.display = '';
  $('cancelDipEdit').style.display = '';
};

function isRuleHit(rule, d){
  const start = dateObj(rule.date);
  if (d < start) return false;
  const diffDays = Math.floor((d - start) / 86400000);
  const freq = rule.freq || 'daily';
  if (freq === 'daily') return true;
  if (freq === 'weekly') return diffDays % 7 === 0;
  if (freq === 'biweekly') return diffDays % 14 === 0;
  if (freq === 'monthly') {
    const sd = start.getDate();
    const md = d.getDate();
    const lastDay = new Date(d.getFullYear(), d.getMonth()+1, 0).getDate();
    return md === sd || (sd > lastDay && md === lastDay);
  }
  return true;
}

function dcaAmountOnDate(dateStr, asset='BTC'){
  const d = dateObj(dateStr);
  const applied = rules.filter(r=>r.asset===asset && r.date<=dateStr).sort((a,b)=>a.date.localeCompare(b.date)).pop();
  if (!applied) return 0;
  return isRuleHit(applied, d) ? Number(applied.amount) : 0;
}

async function fetchCC(tsym, limit=2000, fsym='BTC'){
  const url = `https://min-api.cryptocompare.com/data/v2/histoday?fsym=${fsym}&tsym=${tsym}&limit=${limit}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Price API failed: ${res.status}`);
  const json = await res.json();
  if (json.Response !== 'Success') throw new Error(json.Message || 'Price API error');
  return json.Data.Data;
}

function toDailyMapCC(rows, fx=1){
  const m = {};
  for (const r of rows) {
    if (!r.time || !r.close) continue;
    const k = new Date(r.time*1000).toISOString().slice(0,10);
    // use OHLC average as approx daily average
    const avg = ((Number(r.open)+Number(r.high)+Number(r.low)+Number(r.close))/4) * fx;
    m[k] = avg;
  }
  return m;
}

function priceForDate(map, d){
  const x = new Date(d);
  for (let i=0;i<10;i++) {
    const k = dayKey(x);
    if (map[k]) return map[k];
    x.setDate(x.getDate()-1);
  }
  return null;
}

$('addRule').onclick = () => {
  const date = $('rDate').value; const amount = Number($('rAmt').value); const freq = $('rFreq').value; const asset = $('rAsset').value;
  if (!date || amount<=0) return alert('Need valid date + amount.');
  const i = rules.findIndex(r=>r.date===date && (r.asset||'BTC')===asset);
  if (i>=0) rules[i] = {date, amount, freq, asset}; else rules.push({date, amount, freq, asset});
  save(); render();
};
$('clearRules').onclick = () => { rules.splice(0, rules.length); save(); render(); };
$('normalizeRules').onclick = () => {
  if (!rules.length) return;
  rules.sort((a,b)=>a.date.localeCompare(b.date));
  const out = [];
  for (const r of rules) {
    const amt = Number(r.amount);
    const freq = r.freq || 'daily';
    const asset = r.asset || 'BTC';
    const prev = out[out.length-1];
    if (!prev || Number(prev.amount) !== amt || (prev.freq||'daily') !== freq || (prev.asset||'BTC') !== asset) out.push({date:r.date, amount:amt, freq, asset});
  }
  rules.splice(0, rules.length, ...out);
  save(); render();
  $('status').textContent = `Normalized rules: ${out.length} effective change(s).`;
};
$('clearAll').onclick = () => {
  if (!confirm('Clear all rules, dip buys, saved inputs, and results?')) return;
  rules.splice(0, rules.length);
  dips.splice(0, dips.length);
  localStorage.removeItem('btc.rules');
  localStorage.removeItem('btc.dips');
  localStorage.removeItem('btc.shakepayBuyLots');
  shakepayBuyLots.splice(0, shakepayBuyLots.length);
  $('result').innerHTML = '';
  if ($('csvResult')) $('csvResult').innerHTML = '';
  $('status').textContent = 'Cleared.';
  resetDipEditor();
  render();
};

function resetDipEditor(){
  editingDipIndex = null;
  $('dDate').value = '';
  $('dAmt').value = '';
  $('dPrice').value = '';
  $('dQty').value = '';
  $('dQtyUnit').value = 'btc';
  $('addDip').style.display = '';
  $('saveDipEdit').style.display = 'none';
  $('cancelDipEdit').style.display = 'none';
}

function readDipForm(){
  const date = $('dDate').value;
  const amount = Number($('dAmt').value || 0);
  const price = Number($('dPrice').value || 0);
  const qty = Number($('dQty').value || 0);
  const qtyUnit = $('dQtyUnit').value;
  if (!date || amount<=0) throw new Error('Need dip date + amount.');
  const btc = qty > 0 && qtyUnit === 'btc' ? qty : null;
  const eth = qty > 0 && qtyUnit === 'eth' ? qty : null;
  const sats = qty > 0 && qtyUnit === 'sats' ? qty : null;
  const asset = eth ? 'ETH' : 'BTC';
  return {date, amount, price: price||null, asset, btc, eth, sats};
}

$('addDip').onclick = () => {
  try {
    dips.push(readDipForm());
    save(); render(); resetDipEditor();
  } catch (e) { alert(e.message); }
};

$('saveDipEdit').onclick = () => {
  try {
    if (editingDipIndex == null || !dips[editingDipIndex]) return alert('No dip selected for edit.');
    dips[editingDipIndex] = readDipForm();
    save(); render(); resetDipEditor();
  } catch (e) { alert(e.message); }
};

$('cancelDipEdit').onclick = () => resetDipEditor();
$('clearDips').onclick = () => { dips.length = 0; save(); render(); resetDipEditor(); };

$('extractDipsFromShakepay').onclick = () => {
  const minCad = Number($('dipMinCad').value || 250);
  const replace = $('replaceDipsOnExtract').checked;
  if (!shakepayBuyLots.length) return alert('No Shakepay buy lots loaded. Upload and Analyze Shakepay first.');
  if (replace) dips.splice(0, dips.length);

  let added = 0;
  for (const lot of shakepayBuyLots) {
    if ((lot.asset || 'BTC') !== 'BTC') continue;
    if (Number(lot.amount) < minCad) continue;
    const key = `BTC|${lot.date}|${Number(lot.amount).toFixed(2)}|${Number(lot.btc||0).toFixed(8)}`;
    const exists = dips.some(d => `BTC|${d.date}|${Number(d.amount).toFixed(2)}|${Number(d.btc||0).toFixed(8)}` === key);
    if (exists) continue;
    const quote = getQuoteMode();
    const amountInQuote = convertAmount(Number(lot.amount), String(lot.ccy||'CAD').toUpperCase(), quote, Number($('fx').value||1.35));
    dips.push({date: lot.date, amount: amountInQuote, price: lot.price || null, btc: Number(lot.btc)||null, sats: null});
    added++;
  }
  save(); render();
  $('status').textContent = `Extracted ${added} dip buy(s) from Shakepay lots using threshold $${fmt(minCad)}.`;
};

$('calc').onclick = async () => {
  const status = $('status');
  status.textContent = 'Fetching market historyâ€¦';

  try {
    const quote = getQuoteMode();
    const fx = Number($('fx').value || 1.35);

    const assetMode = getAssetMode();
    const activeAssets = assetMode === 'bteth' ? ['BTC','ETH'] : ['BTC'];

    const maps = {};
    let sourceLabel = '';
    for (const a of activeAssets) {
      const rows = await fetchCC(quote, 2000, a);
      maps[a] = toDailyMapCC(rows, 1);
    }
    sourceLabel = `CryptoCompare ${activeAssets.join('/')} ${quote} (OHLC avg/day)`;
    const map = maps['BTC'];

    const mode = $('calcMode').value;
    const useRules = mode === 'rules' || mode === 'hybrid';
    const useShakepayLots = mode === 'shakepay' || mode === 'hybrid';
    let invested=0, btc=0, dcaInvested=0, dipInvested=0, skipped=0;
    let dcaBtc=0, dipBtc=0, shakepayBtc=0, shakepayInvested=0;
    const assetStats = { BTC:{invested:0, qty:0}, ETH:{invested:0, qty:0} };

    if (useRules && rules.length) {
      const start = rules.map(r=>r.date).sort()[0];
      for (let d=dateObj(start), end=new Date(); d<=end; d.setDate(d.getDate()+1)) {
        const k = dayKey(d);
        const amountBtc = dcaAmountOnDate(k, 'BTC');
        const amountEth = dcaAmountOnDate(k, 'ETH');

        if (amountBtc > 0) {
          const pxB = priceForDate(maps['BTC'], d);
          if (!pxB) { skipped++; } else {
            const gotB = amountBtc / pxB;
            invested += amountBtc; dcaInvested += amountBtc; btc += gotB; dcaBtc += gotB;
            assetStats.BTC.invested += amountBtc; assetStats.BTC.qty += gotB;
          }
        }

        if (amountEth > 0) {
          const pxE = priceForDate(maps['ETH'] || maps['BTC'], d);
          if (!pxE) { skipped++; } else {
            const gotE = amountEth / pxE;
            invested += amountEth; dcaInvested += amountEth;
            assetStats.ETH.invested += amountEth; assetStats.ETH.qty += gotE;
          }
        }
      }
    }

    if (useRules) for (const dip of dips) {
      const asset = (dip.asset || 'BTC').toUpperCase();
      let got = 0;
      if (asset === 'ETH') {
        if (dip.eth) got = Number(dip.eth);
        else if (dip.price) got = Number(dip.amount)/Number(dip.price);
        else {
          const px = priceForDate(maps['ETH'] || maps['BTC'], dateObj(dip.date));
          if (!px) { skipped++; continue; }
          got = Number(dip.amount)/px;
        }
      } else {
        if (dip.btc) got = Number(dip.btc);
        else if (dip.sats) got = Number(dip.sats)/SATS;
        else if (dip.price) got = Number(dip.amount)/Number(dip.price);
        else {
          const px = priceForDate(maps['BTC'], dateObj(dip.date));
          if (!px) { skipped++; continue; }
          got = Number(dip.amount)/px;
        }
      }
      invested += Number(dip.amount);
      dipInvested += Number(dip.amount);
      if (asset === 'BTC') { btc += got; dipBtc += got; }
      assetStats[asset] = assetStats[asset] || {invested:0, qty:0};
      assetStats[asset].invested += Number(dip.amount);
      assetStats[asset].qty += got;
    }

    if (useShakepayLots && shakepayBuyLots.length) {
      const dipKeys = new Set(dips.map(d => `BTC|${d.date}|${Number(d.amount).toFixed(2)}|${(Number(d.btc||0)).toFixed(8)}`));
      let lotsIncluded = 0;
      for (const lot of shakepayBuyLots) {
        const asset = (lot.asset || 'BTC').toUpperCase();
        const key = `${asset}|${lot.date}|${Number(lot.amount).toFixed(2)}|${(Number(lot.btc||0)).toFixed(8)}`;
        if (asset === 'BTC' && dipKeys.has(key)) continue; // avoid double-count if same BTC buy already imported as dip
        const amountInQuote = convertAmount(Number(lot.amount), String(lot.ccy||'CAD').toUpperCase(), quote, fx);
        invested += amountInQuote;
        const qty = Number(lot.btc || 0);
        if (asset === 'BTC') shakepayBtc += qty;
        shakepayInvested += amountInQuote;
        assetStats[asset] = assetStats[asset] || {invested:0, qty:0};
        assetStats[asset].invested += amountInQuote;
        assetStats[asset].qty += qty;
        btc += asset === 'BTC' ? qty : 0;
        lotsIncluded++;
      }
      if (lotsIncluded) status.textContent = `Included ${lotsIncluded} Shakepay buy lot(s) from upload.`;
      if (mode === 'hybrid' && rules.length && lotsIncluded) status.textContent += ' Warning: Hybrid mode may overlap DCA rules and imported buys.';
    }

    const hasRuleInputs = rules.length || dips.length;
    const hasShakepayInputs = shakepayBuyLots.length;
    if ((useRules && !hasRuleInputs) && (useShakepayLots && !hasShakepayInputs)) {
      throw new Error('No inputs for selected mode. Add rules/dips and/or import Shakepay first.');
    }
    if (useRules && !useShakepayLots && !hasRuleInputs) {
      throw new Error('Rules only mode selected, but no rules/dips found.');
    }
    if (useShakepayLots && !useRules && !hasShakepayInputs) {
      throw new Error('Shakepay only mode selected, but no imported Shakepay buys found.');
    }

    const current = priceForDate(maps['BTC'], new Date());
    if (!current) throw new Error('Could not get recent BTC price from source.');
    const currentEth = maps['ETH'] ? priceForDate(maps['ETH'], new Date()) : null;
    localStorage.setItem('btc.lastCurrentPriceCad', String(current));

    const value = (assetStats.BTC.qty * current) + (assetStats.ETH.qty * (currentEth || 0));
    const pnl = value - invested;
    const roi = invested ? (pnl/invested)*100 : 0;

    const dcaValue = dcaBtc * current;
    const dcaPnl = dcaValue - dcaInvested;
    const dcaRoi = dcaInvested ? (dcaPnl / dcaInvested) * 100 : null;

    const dipValue = dipBtc * current;
    const dipPnl = dipValue - dipInvested;
    const dipRoi = dipInvested ? (dipPnl / dipInvested) * 100 : null;

    $('status').innerHTML = `Done. Source: <b>${sourceLabel}</b>.`;
    render();
    $('result').innerHTML = `
      <div class="cards">
        <div class="card"><div class="small">Total Invested</div><b>$${fmt(invested)}</b></div>
        <div class="card"><div class="small">From DCA</div><b>$${fmt(dcaInvested)}</b></div>
        <div class="card"><div class="small">From Dip Buys</div><b>$${fmt(dipInvested)}</b></div>
        <div class="card"><div class="small">Estimated BTC</div><b>${assetStats.BTC.qty.toFixed(8)} BTC</b></div>
      </div>
      <div class="cards" style="margin-top:10px">
        <div class="card"><div class="small">Current BTC Price</div><b>$${fmt(current)}</b></div>
        ${assetMode === 'bteth' ? `<div class="card"><div class="small">Current ETH Price</div><b>${currentEth?('$'+fmt(currentEth)):'n/a'}</b></div>` : ''}
        <div class="card"><div class="small">Portfolio Value</div><b>$${fmt(value)}</b></div>
        <div class="card"><div class="small">Total PnL</div><b class="${pnl>=0?'ok':'warn'}">$${fmt(pnl)}</b></div>
      </div>
      <div class="cards" style="margin-top:10px">
        <div class="card"><div class="small">Total ROI</div><b class="${roi>=0?'ok':'warn'}">${roi.toFixed(2)}%</b></div>
        <div class="card"><div class="small">Total BTC ROI</div><b class="${assetStats.BTC.invested?((((assetStats.BTC.qty*current-assetStats.BTC.invested)/assetStats.BTC.invested*100)>=0)?'ok':'warn'):''}">${assetStats.BTC.invested?(((assetStats.BTC.qty*current-assetStats.BTC.invested)/assetStats.BTC.invested*100).toFixed(2)+'%'):'n/a'}</b></div>
        <div class="card"><div class="small">Total BTC PnL</div><b class="${((assetStats.BTC.qty*current-assetStats.BTC.invested)>=0)?'ok':'warn'}">${assetStats.BTC.invested?('$'+fmt(assetStats.BTC.qty*current-assetStats.BTC.invested)):'n/a'}</b></div>
        ${assetMode === 'bteth' ? `<div class="card"><div class="small">Total ETH ROI</div><b class="${(assetStats.ETH.invested&&currentEth)?((((assetStats.ETH.qty*currentEth-assetStats.ETH.invested)/assetStats.ETH.invested*100)>=0)?'ok':'warn'):''}">${(assetStats.ETH.invested&&currentEth)?(((assetStats.ETH.qty*currentEth-assetStats.ETH.invested)/assetStats.ETH.invested*100).toFixed(2)+'%'):'n/a'}</b></div>` : ''}
      </div>
      ${assetMode === 'bteth' ? `<div class="cards" style="margin-top:10px"><div class="card"><div class="small">Total ETH PnL</div><b class="${((assetStats.ETH.qty*(currentEth||0)-assetStats.ETH.invested)>=0)?'ok':'warn'}">${assetStats.ETH.invested?('$'+fmt(assetStats.ETH.qty*(currentEth||0)-assetStats.ETH.invested)):'n/a'}</b></div></div>` : ''}
      <div class="cards" style="margin-top:10px">
        <div class="card"><div class="small">Total DCA ROI</div><b class="${dcaRoi==null?'':(dcaRoi>=0?'ok':'warn')}">${dcaRoi==null?'n/a':dcaRoi.toFixed(2)+'%'}</b></div>
        <div class="card"><div class="small">Total DCA PnL</div><b class="${dcaRoi==null?'':(dcaPnl>=0?'ok':'warn')}">${dcaRoi==null?'n/a':'$'+fmt(dcaPnl)}</b></div>
        <div class="card"><div class="small">Total Dip ROI</div><b class="${dipRoi==null?'':(dipRoi>=0?'ok':'warn')}">${dipRoi==null?'n/a':dipRoi.toFixed(2)+'%'}</b></div>
        <div class="card"><div class="small">Total Dip PnL</div><b class="${dipRoi==null?'':(dipPnl>=0?'ok':'warn')}">${dipRoi==null?'n/a':'$'+fmt(dipPnl)}</b></div>
      </div>
      <p class="small" style="margin-top:10px">Mode: <b>${mode}</b>. Asset mode: <b>${assetMode === 'bteth' ? 'BTC+ETH' : 'BTC only'}</b>. Skipped days/entries due to missing price data: ${skipped}. Imported Shakepay buys included: ${useShakepayLots ? ('$'+fmt(shakepayInvested)+' '+quote) : 'off'}.</p>`;
  } catch (e) {
    status.textContent = 'Error: ' + e.message;
  }
};

function parseCsv(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return [];

  const splitCsvLine = (line) =>
    line
      .split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/)
      .map(v => v.trim().replace(/^"|"$/g, '').replace(/""/g, '"'));

  const head = splitCsvLine(lines[0]).map(s=>s.trim().toLowerCase());
  return lines.slice(1).map(line => {
    const cols = splitCsvLine(line);
    const o = {};
    head.forEach((h,i)=> o[h]= (cols[i]||'').trim());
    return o;
  });
}

function num(v){
  if (v == null) return 0;
  const cleaned = String(v).replace(/[$,\s]/g,'');
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : 0;
}

function normalizeShakepayRow(r){
  return {
    date: (r['date'] || '').trim(),
    amountDebited: num(r['amount debited']),
    assetDebited: (r['asset debited'] || '').trim().toUpperCase(),
    amountCredited: num(r['amount credited']),
    assetCredited: (r['asset credited'] || '').trim().toUpperCase(),
    marketValue: num(r['market value']),
    marketValueCurrency: (r['market value currency'] || '').trim().toUpperCase(),
    bookCost: num(r['book cost']),
    bookCostCurrency: (r['book cost currency'] || '').trim().toUpperCase(),
    type: (r['type'] || '').trim(),
    spotRate: num(r['spot rate']),
    buySellRate: num(r['buy / sell rate']),
    description: (r['description'] || '').trim() || '(Unlabeled)'
  };
}

$('analyzeShakepay').onclick = async () => {
  try {
    const file = $('shakepayFile').files[0];
    if (!file) throw new Error('Pick your Shakepay CSV first.');

    const text = await file.text();
    const rows = parseCsv(text).map(normalizeShakepayRow);
    if (!rows.length) throw new Error('No rows found in Shakepay file.');

    const mode = getAssetMode();
    const quote = getQuoteMode();
    const assets = mode === 'bteth' ? ['BTC','ETH'] : ['BTC'];

    const assetRows = rows.filter(r => assets.includes(r.assetCredited));
    if (!assetRows.length) throw new Error(`No ${assets.join('/')} rows found.`);

    const sentRows = rows.filter(r => assets.includes(r.assetDebited));

    const dates = assetRows.map(r => r.date).filter(Boolean).sort();
    const start = dates[0] || 'n/a';
    const end = dates[dates.length-1] || 'n/a';

    let buyCad = 0;
    let buyUnits = 0;
    let buyBtcUnits = 0;
    let buyEthUnits = 0;
    const parsedBuyLots = [];
    let rewardUnits = 0;
    let rewardBtcUnits = 0;
    let recvUnits = 0;
    let sentUnits = 0;
    let recvBtcUnits = 0, recvEthUnits = 0;
    let sentBtcUnits = 0, sentEthUnits = 0;

    const rewardByDesc = {};

    for (const r of assetRows) {
      const type = r.type.toLowerCase();
      const date = (r.date || '').slice(0,10);
      const qty = r.amountCredited || 0;
      const sats = r.assetCredited === 'BTC' ? Math.round(qty * SATS) : 0;

      if (type === 'reward') {
        rewardUnits += qty;
        if ((r.assetCredited||'').toUpperCase() === 'BTC') {
          rewardBtcUnits += qty;
          rewardByDesc[r.description] = (rewardByDesc[r.description] || 0) + sats;
        }
      } else if (type === 'receive') {
        recvUnits += qty;
        if ((r.assetCredited||'').toUpperCase() === 'BTC') recvBtcUnits += qty;
        if ((r.assetCredited||'').toUpperCase() === 'ETH') recvEthUnits += qty;
      } else {
        const isCostBearingBtcAcquisition = (type === 'buy' || type === 'convert' || type === 'other') && ((r.bookCost > 0) || (r.marketValue > 0));
        if (isCostBearingBtcAcquisition) {
          const amount = r.bookCost > 0 ? r.bookCost : r.marketValue;
          const amountCcy = (r.bookCostCurrency || r.marketValueCurrency || 'CAD').toUpperCase();
          const amountInQuote = convertAmount(amount, amountCcy, quote, Number($('fx').value||1.35));
          const price = r.buySellRate > 0 ? r.buySellRate : (r.spotRate > 0 ? r.spotRate : null);
          if (date && amount > 0) parsedBuyLots.push({date, amount, ccy: amountCcy, btc: qty || 0, asset: r.assetCredited || 'BTC', price: price || null});
          if (amount > 0) {
            buyCad += amountInQuote;
            buyUnits += qty;
            if ((r.assetCredited||'').toUpperCase() === 'BTC') buyBtcUnits += qty;
            if ((r.assetCredited||'').toUpperCase() === 'ETH') buyEthUnits += qty;
          }
        }
      }
    }

    sentUnits = sentRows.reduce((sum, r) => sum + (r.amountDebited || 0), 0);
    sentBtcUnits = sentRows.filter(r => (r.assetDebited||'').toUpperCase()==='BTC').reduce((sum,r)=>sum+(r.amountDebited||0),0);
    sentEthUnits = sentRows.filter(r => (r.assetDebited||'').toUpperCase()==='ETH').reduce((sum,r)=>sum+(r.amountDebited||0),0);

    shakepayBuyLots.splice(0, shakepayBuyLots.length, ...parsedBuyLots);
    localStorage.setItem('btc.shakepayBuyLots', JSON.stringify(shakepayBuyLots));

    let rewardsFiatToday = null;
    try {
      const qRows = await fetchCC(quote, 10, 'BTC');
      const qMap = toDailyMapCC(qRows, 1);
      const qNow = priceForDate(qMap, new Date());
      if (qNow) rewardsFiatToday = rewardBtcUnits * qNow;
    } catch {}

    save(); render();

    const rewardRows = Object.entries(rewardByDesc)
      .sort((a,b)=>b[1]-a[1])
      .map(([k,v])=>`<tr><td>${esc(k)}</td><td>${Number(v).toLocaleString()}</td><td>${(v/SATS).toFixed(8)} BTC</td></tr>`)
      .join('');

    $('shakepayResult').innerHTML = `
      <p class="ok"><b>Shakepay import complete.</b></p>
      <div class="cards" style="margin-top:8px">
        <div class="card"><div class="small">Date range (${esc(assets.join('/'))} rows)</div><b>${esc(start)} â†’ ${esc(end)}</b></div>
        <div class="card"><div class="small">${esc(assets.join('/'))} buy rows parsed from file</div><b>${parsedBuyLots.length}</b></div>
        <div class="card"><div class="small">Total buy ${quote} (all selected assets)</div><b>$${fmt(buyCad)}</b></div>
        <div class="card"><div class="small">BTC units credited</div><b>${buyBtcUnits.toFixed(8)} BTC</b></div>
      </div>
      <div class="cards" style="margin-top:10px">
        <div class="card"><div class="small">ETH units credited</div><b>${buyEthUnits.toFixed(8)} ETH</b></div>
      </div>
      <div class="card" style="margin-top:10px">
        <div class="small">Shakepay Rewards Breakdown (BTC)</div>
        <p><b>Total rewards (BTC):</b> ${rewardBtcUnits.toFixed(8)} (${Math.round(rewardBtcUnits*SATS).toLocaleString()} sats)${rewardsFiatToday!=null ? ` â‰ˆ <b>$${fmt(rewardsFiatToday)} ${quote}</b> today` : ''}</p>
        ${rewardRows ? `<table><thead><tr><th>Reward source</th><th>Sats</th><th>BTC</th></tr></thead><tbody>${rewardRows}</tbody></table>` : '<p class="small">No reward rows found.</p>'}
      </div>
    `;

    const netBtcFlow = buyBtcUnits + rewardBtcUnits + recvBtcUnits - sentBtcUnits;
    const netEthFlow = buyEthUnits + recvEthUnits - sentEthUnits;
    $('flowResult').innerHTML = `
      <div class="cards">
        <div class="card"><div class="small">BTC Bought</div><b>${buyBtcUnits.toFixed(8)} BTC</b></div>
        <div class="card"><div class="small">BTC Rewards</div><b>${rewardBtcUnits.toFixed(8)} BTC</b></div>
        <div class="card"><div class="small">BTC Received</div><b>${recvBtcUnits.toFixed(8)} BTC</b></div>
        <div class="card"><div class="small">BTC Sent</div><b>${sentBtcUnits.toFixed(8)} BTC</b></div>
      </div>
      <div class="card" style="margin-top:10px"><div class="small">Net BTC Flow</div><b>${netBtcFlow.toFixed(8)} BTC</b></div>
      ${mode === 'bteth' ? `<div class="cards" style="margin-top:10px"><div class="card"><div class="small">ETH Bought</div><b>${buyEthUnits.toFixed(8)} ETH</b></div><div class="card"><div class="small">ETH Received</div><b>${recvEthUnits.toFixed(8)} ETH</b></div><div class="card"><div class="small">ETH Sent</div><b>${sentEthUnits.toFixed(8)} ETH</b></div><div class="card"><div class="small">Net ETH Flow</div><b>${netEthFlow.toFixed(8)} ETH</b></div></div>` : ''}
      <p class="small" style="margin-top:8px">Use this as a reconciliation helper against your exchange balance snapshot date.</p>
    `;

    // Auto-calculate once right after successful import/analyze
    $('calc').click();
  } catch (e) {
    $('shakepayResult').innerHTML = `<p class="small warn">${esc(e.message)}</p>`;
    $('flowResult').innerHTML = '';
  }
};

render();
</script>
</body>
</html>