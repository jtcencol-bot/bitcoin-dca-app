<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bitcoin DCA Calculator (CAD)</title>
  <style>
    :root{--bg:#0b1020;--panel:#141a2e;--line:#2a3458;--text:#ecf0ff;--muted:#a6b2d1;--ok:#22c55e;--warn:#f59e0b}
    *{box-sizing:border-box} body{margin:0;font-family:Inter,system-ui,sans-serif;background:var(--bg);color:var(--text)}
    .wrap{max-width:1080px;margin:0 auto;padding:18px} .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:14px;margin-bottom:12px}
    h1{margin:0 0 8px} .sub{color:var(--muted);margin:0 0 12px} label{display:block;color:var(--muted);margin:6px 0 4px}
    input,button,select{width:100%;padding:10px;border-radius:10px;border:1px solid #3a4670;background:#0f1630;color:var(--text)}
    button{background:#22305c;cursor:pointer;font-weight:700} .grid{display:grid;gap:10px}
    .g5{grid-template-columns:repeat(5,1fr)} .g4{grid-template-columns:repeat(4,1fr)} .g3{grid-template-columns:repeat(3,1fr)}
    .list{display:grid;gap:8px}.item{background:#0f1630;border:1px solid #3a4670;border-radius:10px;padding:8px}
    .cards{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}.card{background:#0f1630;border:1px solid #3a4670;border-radius:10px;padding:10px}
    .small{font-size:.9rem;color:var(--muted)} .ok{color:var(--ok)} .warn{color:var(--warn)} .actions{display:flex;gap:8px;flex-wrap:wrap}.actions button{width:auto}
    .dateWrap{display:flex;gap:6px}.dateWrap input{flex:1}.dateWrap button{width:auto;padding:8px 10px}
    table{width:100%;border-collapse:collapse} th,td{border-bottom:1px solid #33406a;padding:8px;text-align:left}
    .hero{display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap}
    .pill{display:inline-block;padding:4px 8px;border:1px solid #3a4670;border-radius:999px;background:#0f1630;color:#b7c3e4;font-size:.8rem}
    dialog{border:1px solid #3a4670;background:#0f1630;color:#ecf0ff;border-radius:12px;max-width:760px;width:min(92vw,760px)}
    dialog::backdrop{background:rgba(0,0,0,.55)}
    @media(max-width:980px){.g5,.g4,.g3,.cards{grid-template-columns:1fr 1fr}}
  </style>
</head>
<body>
<div class="wrap">
  <div class="hero">
    <div>
      <h1 style="margin:0;">Bitcoin DCA Calculator (CAD)</h1>
      <p class="sub" style="margin:6px 0 8px;">DCA = <b>Dollar-Cost Averaging</b> (aka recurring buys over time). Track recurring buys, dip buys, and estimated returns in CAD.</p>
      <span class="pill">Not financial/tax advice</span>
    </div>
    <div class="actions">
      <button id="helpBtn" type="button">Help</button>
      <button id="demoBtn" type="button">Load Demo Data</button>
      <button id="clearAll" type="button" style="background:#5b1f2a;border-color:#7a2a39;">Clear All</button>
    </div>
  </div>

  <section class="panel">
    <h2>Shakepay Import (recommended first step)</h2>
    <p class="small">If you use Shakepay, upload <code>crypto_transactions_summary.csv</code> first to save time. The app imports BTC buys, analyzes rewards, and shows BTC flow. ETH rows are ignored for now (future versions can include ETH). If you do not use Shakepay, enter your information manually below.</p>
    <div class="grid g3">
      <div><label>Shakepay CSV</label><input id="shakepayFile" type="file" accept=".csv,text/csv"></div>
      <div><label>&nbsp;</label><button id="analyzeShakepay" type="button">Analyze Shakepay</button></div>
      <div></div>
    </div>
    <div id="shakepayResult" style="margin-top:10px"></div>
  </section>
  <section class="panel">
    <h2>DCA / Auto-Buy Rules (daily CAD)</h2>
    <div class="grid g4">
      <div>
        <label>Start Date</label>
        <div class="dateWrap"><input id="rDate" type="date" value="2021-10-31"><button id="pickRDate" type="button">ðŸ“…</button></div>
      </div>
      <div><label>Daily Amount (CAD)</label><input id="rAmt" type="number" min="0" step="0.01" value="15"></div>
      <div><label>&nbsp;</label><button id="addRule">Add / Update Rule</button></div>
      <div><label>&nbsp;</label><button id="clearRules">Clear Rules</button></div>
    </div>
    <div class="actions" style="margin-top:10px">
      <button id="normalizeRules" type="button">Normalize Rules (remove duplicates)</button>
    </div>
    <div id="ruleList" class="list" style="margin-top:10px"></div>
  </section>

  <section class="panel">
    <h2>Dip Buys (CAD)</h2>
    <p class="small">Optional override fields let you use your books exactly (price + BTC or sats).</p>
    <div class="grid g5">
      <div>
        <label>Date</label>
        <div class="dateWrap"><input id="dDate" type="date"><button id="pickDDate" type="button">ðŸ“…</button></div>
      </div>
      <div><label>Amount Paid (CAD)</label><input id="dAmt" type="number" min="0" step="0.01" placeholder="1000"></div>
      <div><label>Book Price (CAD/BTC, optional)</label><input id="dPrice" type="number" min="0" step="0.01" placeholder="90000"></div>
      <div><label>Received Amount (optional)</label><input id="dQty" type="number" min="0" step="0.00000001" placeholder="0.01111112"></div>
      <div><label>Received Unit</label><select id="dQtyUnit"><option value="btc">BTC</option><option value="sats">sats</option></select></div>
    </div>
    <div class="actions" style="margin-top:10px">
      <button id="addDip">Add Dip Buy</button>
      <button id="saveDipEdit" style="display:none;">Save Dip Edit</button>
      <button id="cancelDipEdit" style="display:none;">Cancel Edit</button>
      <button id="clearDips">Clear Dip Buys</button>
    </div>
    <div class="grid g3" style="margin-top:10px">
      <div><label>Min CAD for dip extraction</label><input id="dipMinCad" type="number" min="0" step="1" value="250"></div>
      <div><label><input id="replaceDipsOnExtract" type="checkbox" checked> Replace existing dips when extracting</label></div>
      <div><label>&nbsp;</label><button id="extractDipsFromShakepay" type="button">Extract Dips from Uploaded Shakepay CSV</button></div>
    </div>
    <div id="dipList" class="list" style="margin-top:10px"></div>
  </section>

  <section class="panel">
    <h2>Price Source & Calculate</h2>
    <div class="grid g3">
      <div>
        <label>Primary Source</label>
        <select id="source"><option value="cc-cad">CryptoCompare BTC/CAD daily</option><option value="cc-usd-fx">CryptoCompare BTC/USD Ã— constant FX</option></select>
      </div>
      <div><label>Fallback FX (USDâ†’CAD)</label><input id="fx" type="number" min="0.5" step="0.0001" value="1.35"></div>
      <div><label>&nbsp;</label><button id="calc">Calculate Returns</button></div>
    </div>
    <div class="grid g3" style="margin-top:10px">
      <div>
        <label>Calculation Mode</label>
        <select id="calcMode">
          <option value="rules">Rules only</option>
          <option value="shakepay" selected>Shakepay only</option>
          <option value="hybrid">Hybrid (advanced)</option>
        </select>
      </div>
      <div><label>&nbsp;</label><span class="small">Rules only = DCA+Dip rules. Shakepay only = imported buys only. Hybrid = both (may overlap).</span></div>
      <div></div>
    </div>
    <p id="status" class="small" style="margin-top:10px">Ready.</p>
    <div id="result" style="margin-top:10px"></div>
  </section>


  <section class="panel">
    <h2>BTC Flow Summary (Shakepay CSV)</h2>
    <p class="small">Visibility only: buys, rewards, received, sent, and net flow from imported Shakepay BTC rows.</p>
    <div id="flowResult"></div>
  </section>
</div>

<dialog id="helpDialog">
  <h3>Quick Guide</h3>
  <ol>
    <li><b>If you use Shakepay</b>, upload your summary first (it can auto-detect DCA rules and import only larger buys as dips).</li>
    <li><b>Add/Edit DCA rules</b>: each rule sets the total daily CAD amount from that date onward.</li>
    <li><b>Add/Edit dip buys</b> (optional): use market price, book price, or exact BTC/sats received.</li>
    <li><b>Calculate Returns</b> to fetch history and estimate BTC, value, and ROI.</li>
  </ol>
  <p class="small">Privacy: your data is stored in your browser (localStorage). Use <b>Clear All</b> to wipe it.</p>
  <div class="actions"><button id="closeHelp" type="button">Close</button></div>
</dialog>

<script>
const SATS = 100000000;
const defaultRules = [];
const rules = JSON.parse(localStorage.getItem('btc.rules') || 'null') || structuredClone(defaultRules);
const dips = JSON.parse(localStorage.getItem('btc.dips') || '[]');
const shakepayBuyLots = JSON.parse(localStorage.getItem('btc.shakepayBuyLots') || '[]');
let editingDipIndex = null;

const $ = id => document.getElementById(id);
const fmt = n => Number(n).toLocaleString(undefined,{maximumFractionDigits:2});
const dayKey = d => new Date(d).toISOString().slice(0,10);
const dateObj = ymd => new Date(ymd+'T00:00:00');
const save = () => { localStorage.setItem('btc.rules', JSON.stringify(rules)); localStorage.setItem('btc.dips', JSON.stringify(dips)); };

function openPicker(input){ if (input.showPicker) input.showPicker(); else input.focus(); }
$('pickRDate').onclick = () => openPicker($('rDate'));
$('pickDDate').onclick = () => openPicker($('dDate'));
$('helpBtn').onclick = () => $('helpDialog').showModal();
$('closeHelp').onclick = () => $('helpDialog').close();
$('demoBtn').onclick = () => {
  rules.splice(0, rules.length, {date:'2024-01-01', amount:5}, {date:'2025-01-01', amount:10});
  dips.splice(0, dips.length, {date:'2025-08-05', amount:500, price:78000, btc:null, sats:null});
  save(); render();
  $('status').textContent = 'Loaded demo data.';
};

function render(){
  rules.sort((a,b)=>a.date.localeCompare(b.date));
  $('ruleList').innerHTML = rules.map((r,i)=>`<div class="item">From <b>${r.date}</b>: <b>$${fmt(r.amount)} CAD/day</b> <button onclick="delRule(${i})" style="width:auto;margin-left:8px">remove</button></div>`).join('') || '<p class="small">No rules.</p>';

  const lastPrice = Number(localStorage.getItem('btc.lastCurrentPriceCad') || 0);

  dips.sort((a,b)=>a.date.localeCompare(b.date));
  $('dipList').innerHTML = dips.map((d,i)=>{
    const btcQty = d.btc ? Number(d.btc) : (d.sats ? Number(d.sats)/SATS : (d.price ? Number(d.amount)/Number(d.price) : 0));
    const detail = d.btc ? `${d.btc.toFixed(8)} BTC` : (d.sats ? `${Number(d.sats).toLocaleString()} sats` : (d.price ? `at $${fmt(d.price)} CAD/BTC` : 'uses market daily avg'));
    let perf = '';
    if (lastPrice > 0 && btcQty > 0) {
      const valNow = btcQty * lastPrice;
      const pnl = valNow - Number(d.amount);
      const roi = Number(d.amount) > 0 ? (pnl / Number(d.amount)) * 100 : 0;
      perf = ` <span class="small">| PnL: <b class="${pnl>=0?'ok':'warn'}">$${fmt(pnl)}</b> | ROI: <b class="${roi>=0?'ok':'warn'}">${roi.toFixed(2)}%</b></span>`;
    }
    return `<div class="item">${d.date}: <b>$${fmt(d.amount)} CAD</b> â€” ${detail}${perf}<button onclick="editDip(${i})" style="width:auto;margin-left:8px">edit</button><button onclick="delDip(${i})" style="width:auto;margin-left:8px">remove</button></div>`;
  }).join('') || '<p class="small">No dip buys.</p>';
}
window.delRule = i => { rules.splice(i,1); save(); render(); };
window.delDip = i => { dips.splice(i,1); save(); render(); };
window.editDip = i => {
  const d = dips[i];
  if (!d) return;
  editingDipIndex = i;
  $('dDate').value = d.date || '';
  $('dAmt').value = d.amount ?? '';
  $('dPrice').value = d.price ?? '';
  $('dQty').value = d.btc ?? (d.sats ?? '');
  $('dQtyUnit').value = d.btc ? 'btc' : (d.sats ? 'sats' : 'btc');
  $('addDip').style.display = 'none';
  $('saveDipEdit').style.display = '';
  $('cancelDipEdit').style.display = '';
};

function dailyAmount(dateStr){
  const applied = rules.filter(r=>r.date<=dateStr).sort((a,b)=>a.date.localeCompare(b.date)).pop();
  return applied ? Number(applied.amount) : 0;
}

async function fetchCC(tsym, limit=2000){
  const url = `https://min-api.cryptocompare.com/data/v2/histoday?fsym=BTC&tsym=${tsym}&limit=${limit}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Price API failed: ${res.status}`);
  const json = await res.json();
  if (json.Response !== 'Success') throw new Error(json.Message || 'Price API error');
  return json.Data.Data;
}

function toDailyMapCC(rows, fx=1){
  const m = {};
  for (const r of rows) {
    if (!r.time || !r.close) continue;
    const k = new Date(r.time*1000).toISOString().slice(0,10);
    // use OHLC average as approx daily average
    const avg = ((Number(r.open)+Number(r.high)+Number(r.low)+Number(r.close))/4) * fx;
    m[k] = avg;
  }
  return m;
}

function priceForDate(map, d){
  const x = new Date(d);
  for (let i=0;i<10;i++) {
    const k = dayKey(x);
    if (map[k]) return map[k];
    x.setDate(x.getDate()-1);
  }
  return null;
}

$('addRule').onclick = () => {
  const date = $('rDate').value; const amount = Number($('rAmt').value);
  if (!date || amount<=0) return alert('Need valid date + amount.');
  const i = rules.findIndex(r=>r.date===date);
  if (i>=0) rules[i].amount = amount; else rules.push({date, amount});
  save(); render();
};
$('clearRules').onclick = () => { rules.splice(0, rules.length); save(); render(); };
$('normalizeRules').onclick = () => {
  if (!rules.length) return;
  rules.sort((a,b)=>a.date.localeCompare(b.date));
  const out = [];
  for (const r of rules) {
    const amt = Number(r.amount);
    if (!out.length || Number(out[out.length-1].amount) !== amt) out.push({date:r.date, amount:amt});
  }
  rules.splice(0, rules.length, ...out);
  save(); render();
  $('status').textContent = `Normalized rules: ${out.length} effective change(s).`;
};
$('clearAll').onclick = () => {
  if (!confirm('Clear all rules, dip buys, saved inputs, and results?')) return;
  rules.splice(0, rules.length);
  dips.splice(0, dips.length);
  localStorage.removeItem('btc.rules');
  localStorage.removeItem('btc.dips');
  localStorage.removeItem('btc.shakepayBuyLots');
  shakepayBuyLots.splice(0, shakepayBuyLots.length);
  $('result').innerHTML = '';
  if ($('csvResult')) $('csvResult').innerHTML = '';
  $('status').textContent = 'Cleared.';
  resetDipEditor();
  render();
};

function resetDipEditor(){
  editingDipIndex = null;
  $('dDate').value = '';
  $('dAmt').value = '';
  $('dPrice').value = '';
  $('dQty').value = '';
  $('dQtyUnit').value = 'btc';
  $('addDip').style.display = '';
  $('saveDipEdit').style.display = 'none';
  $('cancelDipEdit').style.display = 'none';
}

function readDipForm(){
  const date = $('dDate').value;
  const amount = Number($('dAmt').value || 0);
  const price = Number($('dPrice').value || 0);
  const qty = Number($('dQty').value || 0);
  const qtyUnit = $('dQtyUnit').value;
  if (!date || amount<=0) throw new Error('Need dip date + amount.');
  const btc = qty > 0 && qtyUnit === 'btc' ? qty : null;
  const sats = qty > 0 && qtyUnit === 'sats' ? qty : null;
  return {date, amount, price: price||null, btc, sats};
}

$('addDip').onclick = () => {
  try {
    dips.push(readDipForm());
    save(); render(); resetDipEditor();
  } catch (e) { alert(e.message); }
};

$('saveDipEdit').onclick = () => {
  try {
    if (editingDipIndex == null || !dips[editingDipIndex]) return alert('No dip selected for edit.');
    dips[editingDipIndex] = readDipForm();
    save(); render(); resetDipEditor();
  } catch (e) { alert(e.message); }
};

$('cancelDipEdit').onclick = () => resetDipEditor();
$('clearDips').onclick = () => { dips.length = 0; save(); render(); resetDipEditor(); };

$('extractDipsFromShakepay').onclick = () => {
  const minCad = Number($('dipMinCad').value || 250);
  const replace = $('replaceDipsOnExtract').checked;
  if (!shakepayBuyLots.length) return alert('No Shakepay buy lots loaded. Upload and Analyze Shakepay first.');
  if (replace) dips.splice(0, dips.length);

  let added = 0;
  for (const lot of shakepayBuyLots) {
    if (Number(lot.amount) < minCad) continue;
    const key = `${lot.date}|${Number(lot.amount).toFixed(2)}|${Number(lot.btc||0).toFixed(8)}`;
    const exists = dips.some(d => `${d.date}|${Number(d.amount).toFixed(2)}|${Number(d.btc||0).toFixed(8)}` === key);
    if (exists) continue;
    dips.push({date: lot.date, amount: Number(lot.amount), price: lot.price || null, btc: Number(lot.btc)||null, sats: null});
    added++;
  }
  save(); render();
  $('status').textContent = `Extracted ${added} dip buy(s) from Shakepay lots using threshold $${fmt(minCad)}.`;
};

$('calc').onclick = async () => {
  const status = $('status');
  status.textContent = 'Fetching BTC historyâ€¦';

  try {
    const source = $('source').value;
    const fx = Number($('fx').value || 1.35);

    let map = {};
    let sourceLabel = '';
    if (source === 'cc-cad') {
      const rows = await fetchCC('CAD', 2000);
      map = toDailyMapCC(rows, 1);
      sourceLabel = 'CryptoCompare BTC/CAD (OHLC avg/day)';
    } else {
      const rows = await fetchCC('USD', 2000);
      map = toDailyMapCC(rows, fx);
      sourceLabel = `CryptoCompare BTC/USD Ã— FX ${fx}`;
    }

    const mode = $('calcMode').value;
    const useRules = mode === 'rules' || mode === 'hybrid';
    const useShakepayLots = mode === 'shakepay' || mode === 'hybrid';
    let invested=0, btc=0, dcaInvested=0, dipInvested=0, skipped=0;
    let dcaBtc=0, dipBtc=0, shakepayBtc=0, shakepayInvested=0;

    if (useRules && rules.length) {
      const start = rules.map(r=>r.date).sort()[0];
      for (let d=dateObj(start), end=new Date(); d<=end; d.setDate(d.getDate()+1)) {
        const k = dayKey(d);
        const amount = dailyAmount(k);
        if (amount<=0) continue;
        const px = priceForDate(map, d);
        if (!px) { skipped++; continue; }
        const got = amount/px;
        invested += amount; dcaInvested += amount; btc += got; dcaBtc += got;
      }
    }

    if (useRules) for (const dip of dips) {
      let btcGot = 0;
      if (dip.btc) btcGot = Number(dip.btc);
      else if (dip.sats) btcGot = Number(dip.sats)/SATS;
      else if (dip.price) btcGot = Number(dip.amount)/Number(dip.price);
      else {
        const px = priceForDate(map, dateObj(dip.date));
        if (!px) { skipped++; continue; }
        btcGot = Number(dip.amount)/px;
      }
      invested += Number(dip.amount);
      dipInvested += Number(dip.amount);
      btc += btcGot;
      dipBtc += btcGot;
    }

    if (useShakepayLots && shakepayBuyLots.length) {
      const dipKeys = new Set(dips.map(d => `${d.date}|${Number(d.amount).toFixed(2)}|${(Number(d.btc||0)).toFixed(8)}`));
      let lotsIncluded = 0;
      for (const lot of shakepayBuyLots) {
        const key = `${lot.date}|${Number(lot.amount).toFixed(2)}|${(Number(lot.btc||0)).toFixed(8)}`;
        if (dipKeys.has(key)) continue; // avoid double-count if same buy already imported as dip
        invested += Number(lot.amount);
        btc += Number(lot.btc || 0);
        shakepayInvested += Number(lot.amount);
        shakepayBtc += Number(lot.btc || 0);
        lotsIncluded++;
      }
      if (lotsIncluded) status.textContent = `Included ${lotsIncluded} Shakepay buy lot(s) from upload.`;
      if (mode === 'hybrid' && rules.length && lotsIncluded) status.textContent += ' Warning: Hybrid mode may overlap DCA rules and imported buys.';
    }

    const hasRuleInputs = rules.length || dips.length;
    const hasShakepayInputs = shakepayBuyLots.length;
    if ((useRules && !hasRuleInputs) && (useShakepayLots && !hasShakepayInputs)) {
      throw new Error('No inputs for selected mode. Add rules/dips and/or import Shakepay first.');
    }
    if (useRules && !useShakepayLots && !hasRuleInputs) {
      throw new Error('Rules only mode selected, but no rules/dips found.');
    }
    if (useShakepayLots && !useRules && !hasShakepayInputs) {
      throw new Error('Shakepay only mode selected, but no imported Shakepay buys found.');
    }

    const current = priceForDate(map, new Date());
    if (!current) throw new Error('Could not get recent BTC price from source.');
    localStorage.setItem('btc.lastCurrentPriceCad', String(current));

    const value = btc * current;
    const pnl = value - invested;
    const roi = invested ? (pnl/invested)*100 : 0;

    const dcaValue = dcaBtc * current;
    const dcaPnl = dcaValue - dcaInvested;
    const dcaRoi = dcaInvested ? (dcaPnl / dcaInvested) * 100 : null;

    const dipValue = dipBtc * current;
    const dipPnl = dipValue - dipInvested;
    const dipRoi = dipInvested ? (dipPnl / dipInvested) * 100 : null;

    $('status').innerHTML = `Done. Source: <b>${sourceLabel}</b>.`;
    render();
    $('result').innerHTML = `
      <div class="cards">
        <div class="card"><div class="small">Total Invested (CAD)</div><b>$${fmt(invested)}</b></div>
        <div class="card"><div class="small">From DCA (CAD)</div><b>$${fmt(dcaInvested)}</b></div>
        <div class="card"><div class="small">From Dip Buys (CAD)</div><b>$${fmt(dipInvested)}</b></div>
        <div class="card"><div class="small">Estimated BTC</div><b>${btc.toFixed(8)} BTC</b></div>
      </div>
      <div class="cards" style="margin-top:10px">
        <div class="card"><div class="small">Current BTC Price (CAD)</div><b>$${fmt(current)}</b></div>
        <div class="card"><div class="small">Portfolio Value (CAD)</div><b>$${fmt(value)}</b></div>
        <div class="card"><div class="small">PnL (CAD)</div><b class="${pnl>=0?'ok':'warn'}">$${fmt(pnl)}</b></div>
        <div class="card"><div class="small">ROI</div><b class="${roi>=0?'ok':'warn'}">${roi.toFixed(2)}%</b></div>
      </div>
      <div class="cards" style="margin-top:10px">
        <div class="card"><div class="small">DCA ROI</div><b>${dcaRoi==null?'n/a':dcaRoi.toFixed(2)+'%'}</b></div>
        <div class="card"><div class="small">DCA PnL (CAD)</div><b class="${dcaRoi==null?'':(dcaPnl>=0?'ok':'warn')}">${dcaRoi==null?'n/a':'$'+fmt(dcaPnl)}</b></div>
        <div class="card"><div class="small">Dip ROI</div><b>${dipRoi==null?'n/a':dipRoi.toFixed(2)+'%'}</b></div>
        <div class="card"><div class="small">Dip PnL (CAD)</div><b class="${dipRoi==null?'':(dipPnl>=0?'ok':'warn')}">${dipRoi==null?'n/a':'$'+fmt(dipPnl)}</b></div>
      </div>
      <p class="small" style="margin-top:10px">Mode: <b>${mode}</b>. Skipped days/entries due to missing price data: ${skipped}. Imported Shakepay buys included: ${useShakepayLots ? ('$'+fmt(shakepayInvested)+' CAD, '+shakepayBtc.toFixed(8)+' BTC') : 'off'}.</p>`;
  } catch (e) {
    status.textContent = 'Error: ' + e.message;
  }
};

function parseCsv(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return [];

  const splitCsvLine = (line) =>
    line
      .split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/)
      .map(v => v.trim().replace(/^"|"$/g, '').replace(/""/g, '"'));

  const head = splitCsvLine(lines[0]).map(s=>s.trim().toLowerCase());
  return lines.slice(1).map(line => {
    const cols = splitCsvLine(line);
    const o = {};
    head.forEach((h,i)=> o[h]= (cols[i]||'').trim());
    return o;
  });
}

function num(v){
  if (v == null) return 0;
  const cleaned = String(v).replace(/[$,\s]/g,'');
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : 0;
}

function normalizeShakepayRow(r){
  return {
    date: (r['date'] || '').trim(),
    amountDebited: num(r['amount debited']),
    assetDebited: (r['asset debited'] || '').trim().toUpperCase(),
    amountCredited: num(r['amount credited']),
    assetCredited: (r['asset credited'] || '').trim().toUpperCase(),
    marketValue: num(r['market value']),
    marketValueCurrency: (r['market value currency'] || '').trim().toUpperCase(),
    bookCost: num(r['book cost']),
    bookCostCurrency: (r['book cost currency'] || '').trim().toUpperCase(),
    type: (r['type'] || '').trim(),
    spotRate: num(r['spot rate']),
    buySellRate: num(r['buy / sell rate']),
    description: (r['description'] || '').trim() || '(Unlabeled)'
  };
}

$('analyzeShakepay').onclick = async () => {
  try {
    const file = $('shakepayFile').files[0];
    if (!file) throw new Error('Pick your Shakepay CSV first.');

    const text = await file.text();
    const rows = parseCsv(text).map(normalizeShakepayRow);
    if (!rows.length) throw new Error('No rows found in Shakepay file.');

    const btcRows = rows.filter(r => r.assetCredited === 'BTC');
    if (!btcRows.length) throw new Error('No BTC rows found.');

    const btcSentRows = rows.filter(r => r.assetDebited === 'BTC');

    const dates = btcRows.map(r => r.date).filter(Boolean).sort();
    const start = dates[0] || 'n/a';
    const end = dates[dates.length-1] || 'n/a';

    let buyCad = 0;
    let buyBtc = 0;
    const parsedBuyLots = [];
    let rewardBtc = 0;
    let recvBtc = 0;
    let sentBtc = 0;

    const rewardByDesc = {};

    for (const r of btcRows) {
      const type = r.type.toLowerCase();
      const date = (r.date || '').slice(0,10);
      const btc = r.amountCredited || 0;
      const sats = Math.round(btc * SATS);

      if (type === 'buy') {
        const amount = r.bookCost > 0 ? r.bookCost : r.marketValue;
        const price = r.buySellRate > 0 ? r.buySellRate : (r.spotRate > 0 ? r.spotRate : null);
        if (date && amount > 0) parsedBuyLots.push({date, amount, btc: btc || 0, price: price || null});
        if (amount > 0) {
          buyCad += amount;
          buyBtc += btc;
        }
      } else if (type === 'reward') {
        rewardBtc += btc;
        rewardByDesc[r.description] = (rewardByDesc[r.description] || 0) + sats;
      } else if (type === 'receive') {
        recvBtc += btc;
      }
    }

    sentBtc = btcSentRows.reduce((sum, r) => sum + (r.amountDebited || 0), 0);

    shakepayBuyLots.splice(0, shakepayBuyLots.length, ...parsedBuyLots);
    localStorage.setItem('btc.shakepayBuyLots', JSON.stringify(shakepayBuyLots));

    let rewardsCadToday = null;
    try {
      const cadRows = await fetchCC('CAD', 10);
      const cadMap = toDailyMapCC(cadRows, 1);
      const cadNow = priceForDate(cadMap, new Date());
      if (cadNow) rewardsCadToday = rewardBtc * cadNow;
    } catch {}

    save(); render();

    const rewardRows = Object.entries(rewardByDesc)
      .sort((a,b)=>b[1]-a[1])
      .map(([k,v])=>`<tr><td>${k}</td><td>${Number(v).toLocaleString()}</td><td>${(v/SATS).toFixed(8)} BTC</td></tr>`)
      .join('');

    $('shakepayResult').innerHTML = `
      <p class="ok"><b>Shakepay import complete.</b></p>
      <div class="cards" style="margin-top:8px">
        <div class="card"><div class="small">Date range (BTC rows)</div><b>${start} â†’ ${end}</b></div>
        <div class="card"><div class="small">BTC buy rows parsed from file</div><b>${parsedBuyLots.length}</b></div>
        <div class="card"><div class="small">Total BTC buy CAD (all buys)</div><b>$${fmt(buyCad)}</b></div>
        <div class="card"><div class="small">Total BTC bought (all buys)</div><b>${buyBtc.toFixed(8)} BTC</b></div>
      </div>
      <div class="card" style="margin-top:10px">
        <div class="small">Rewards breakdown (BTC only)</div>
        <p><b>Total rewards:</b> ${rewardBtc.toFixed(8)} BTC (${Math.round(rewardBtc*SATS).toLocaleString()} sats)${rewardsCadToday!=null ? ` â‰ˆ <b>$${fmt(rewardsCadToday)} CAD</b> today` : ''}</p>
        ${rewardRows ? `<table><thead><tr><th>Reward source</th><th>Sats</th><th>BTC</th></tr></thead><tbody>${rewardRows}</tbody></table>` : '<p class="small">No reward rows found.</p>'}
      </div>
      <p class="small" style="margin-top:8px">Tip: keep DCA rules manual for accuracy; use Shakepay import mainly for analysis and rewards.</p>
    `;

    const netFlow = buyBtc + rewardBtc + recvBtc - sentBtc;
    $('flowResult').innerHTML = `
      <div class="cards">
        <div class="card"><div class="small">BTC Bought</div><b>${buyBtc.toFixed(8)}</b></div>
        <div class="card"><div class="small">BTC Rewards</div><b>${rewardBtc.toFixed(8)}</b></div>
        <div class="card"><div class="small">BTC Received</div><b>${recvBtc.toFixed(8)}</b></div>
        <div class="card"><div class="small">BTC Sent</div><b>${sentBtc.toFixed(8)}</b></div>
      </div>
      <div class="card" style="margin-top:10px"><div class="small">Net BTC Flow (Bought + Rewards + Received - Sent)</div><b>${netFlow.toFixed(8)} BTC</b></div>
      <p class="small" style="margin-top:8px">Use this as a reconciliation helper against your exchange balance snapshot date.</p>
    `;
  } catch (e) {
    $('shakepayResult').innerHTML = `<p class="small warn">${e.message}</p>`;
    $('flowResult').innerHTML = '';
  }
};

render();
</script>
</body>
</html>