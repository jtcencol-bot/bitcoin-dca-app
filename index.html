<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bitcoin DCA Calculator (CAD)</title>
  <style>
    :root{--bg:#0b1020;--panel:#141a2e;--line:#2a3458;--text:#ecf0ff;--muted:#a6b2d1;--ok:#22c55e;--warn:#f59e0b;--accent:#f7931a;--glow:rgba(247,147,26,.25)}
body.mode-btc{--accent:#f7931a;--bg:#120b03;--panel:#1e1308;--line:#5c3a12;--muted:#e5c39b;--glow:rgba(247,147,26,.26)}
body.mode-bteth{--accent:#60a5fa;--bg:#070d1b;--panel:#101a31;--line:#2a3458;--muted:#a6b2d1;--glow:rgba(96,165,250,.28)}
    *{box-sizing:border-box} body{margin:0;font-family:Inter,system-ui,sans-serif;background:var(--bg);color:var(--text)}
    .wrap{max-width:1080px;margin:0 auto;padding:18px}
    .panel{background:linear-gradient(180deg, color-mix(in srgb, var(--panel) 92%, #ffffff 8%), var(--panel));border:1px solid var(--line);border-radius:14px;padding:14px;margin-bottom:12px;box-shadow:0 0 0 1px rgba(255,255,255,.03),0 12px 30px rgba(0,0,0,.28),0 0 30px var(--glow)}
    h1{margin:0 0 8px} .sub{color:var(--muted);margin:0 0 12px} label{display:block;color:var(--muted);margin:6px 0 4px}
    input,button,select{width:100%;padding:10px;border-radius:10px;border:1px solid #3a4670;background:#0f1630;color:var(--text)}
    input[type="radio"],input[type="checkbox"]{width:auto;padding:0;border:0;background:transparent;accent-color:var(--accent)}
    button{background:#22305c;cursor:pointer;font-weight:700;transition:transform .15s ease, box-shadow .2s ease, border-color .2s ease}
    button:hover{transform:translateY(-1px);box-shadow:0 6px 18px rgba(0,0,0,.25);border-color:color-mix(in srgb, var(--accent) 45%, #3a4670)}
    .grid{display:grid;gap:10px}
    h1{color:var(--accent)}
    .g6{grid-template-columns:repeat(6,1fr)} .g5{grid-template-columns:repeat(5,1fr)} .g4{grid-template-columns:repeat(4,1fr)} .g3{grid-template-columns:repeat(3,1fr)}
    .list{display:grid;gap:8px}.item{background:#0f1630;border:1px solid #3a4670;border-radius:10px;padding:8px}
    .cards{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
    .card{background:linear-gradient(160deg, rgba(15,22,48,.9), rgba(9,14,32,.95));border:1px solid #3a4670;border-radius:12px;padding:10px;position:relative;overflow:hidden}
    .card::after{content:'';position:absolute;inset:auto -20% -70% -20%;height:120px;background:radial-gradient(ellipse at center, var(--glow), transparent 65%);pointer-events:none}
    .small{font-size:.9rem;color:var(--muted)} .ok{color:var(--ok)} .warn{color:var(--warn)} .actions{display:flex;gap:8px;flex-wrap:wrap}.actions button{width:auto}
    .dateWrap{display:flex;gap:6px}.dateWrap input{flex:1}.dateWrap button{width:auto;padding:8px 10px}
    table{width:100%;border-collapse:collapse} th,td{border-bottom:1px solid #33406a;padding:8px;text-align:left}
    .hero{display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap}
    .pill{display:inline-block;padding:4px 8px;border:1px solid #3a4670;border-radius:999px;background:#0f1630;color:#b7c3e4;font-size:.8rem}
    .chip{width:auto;padding:6px 10px;font-size:.85rem;border-radius:999px}
    dialog{border:1px solid #3a4670;background:#0f1630;color:#ecf0ff;border-radius:12px;max-width:760px;width:min(92vw,760px)}
    dialog::backdrop{background:rgba(0,0,0,.55)}
    .chartWrap{margin-top:12px;background:linear-gradient(180deg,rgba(8,14,32,.9),rgba(6,10,24,.95));border:1px solid #2d3c67;border-radius:12px;padding:10px}
    .chartLegend{display:flex;gap:12px;flex-wrap:wrap;margin:8px 0 0}
    .dot{display:inline-block;width:10px;height:10px;border-radius:999px;margin-right:6px}
    @media(max-width:980px){
      .g6,.g5,.g4,.g3,.cards{grid-template-columns:1fr 1fr}
      .hero .actions{width:100%}
    }
    #mobileQuickNav{display:none}
    #mobileStickyActions{display:none}
    @media(max-width:640px){
      .wrap{padding:12px;padding-bottom:86px}
      .g6,.g5,.g4,.g3,.cards{grid-template-columns:1fr}
      .actions{gap:6px}
      .actions button{width:100%}
      .dateWrap{flex-direction:column}
      .dateWrap button{width:100%}
      .panel{padding:12px}
      h1{font-size:2rem;line-height:1.1}
      h2{font-size:1.35rem;line-height:1.2;cursor:pointer}
      #mobileQuickNav{display:block;position:sticky;top:0;z-index:20;background:var(--bg)}
      #mobileQuickNav .actions{display:grid;grid-template-columns:repeat(4,1fr)}
      #mobileQuickNav .actions button{width:100%}
      #mobileStickyActions{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;position:fixed;left:0;right:0;bottom:0;padding:10px;background:rgba(8,12,24,.95);border-top:1px solid var(--line);z-index:50}
      #mobileStickyActions button{padding:12px}
      .panel.collapsed > :not(h2){display:none}
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="hero">
    <div>
      <h1 id="appTitle" style="margin:0;">Bitcoin DCA Calculator (CAD)</h1>
      <p class="sub" style="margin:6px 0 8px;">DCA = <b>Dollar-Cost Averaging</b> (aka recurring buys over time). Track recurring buys, dip buys, and estimated returns in CAD. Toggle BTC-only vs BTC+ETH at top.</p>
      <span class="pill">Not financial/tax advice</span>
    </div>
    <div class="actions">
      <label class="small" style="display:flex;align-items:center;gap:6px"><input type="radio" name="assetMode" value="btc" checked> Bitcoin-Only Mode</label>
      <label class="small" style="display:flex;align-items:center;gap:6px"><input type="radio" name="assetMode" value="bteth"> BTC + ETH Mode</label>
      <label class="small" style="display:flex;align-items:center;gap:6px"><input type="radio" name="quoteMode" value="CAD" checked> CAD</label>
      <label class="small" style="display:flex;align-items:center;gap:6px"><input type="radio" name="quoteMode" value="USD"> USD</label>
      <button id="helpBtn" type="button">Help</button>
            <button id="clearAll" type="button" style="background:#5b1f2a;border-color:#7a2a39;">Clear All</button>
    </div>
  </div>

  <div class="panel" id="mobileQuickNav">
    <div class="actions">
      <button type="button" class="chip" id="jumpShakepay">Shakepay</button>
      <button type="button" class="chip" id="jumpRules">Rules</button>
      <button type="button" class="chip" id="jumpDips">Dips</button>
      <button type="button" class="chip" id="jumpReturns">Returns</button>
    </div>
  </div>

  <section class="panel" id="sec-shakepay">
    <h2>Shakepay Import (recommended first step)</h2>
    <p class="small">If you use Shakepay, upload <code>crypto_transactions_summary.csv</code> first to save time. Asset mode controls whether BTC-only rows or BTC+ETH rows are included in analysis. If you do not use Shakepay, enter your information manually below. Data is processed in-browser and saved only to this browser profile.</p>
    <div class="grid g3">
      <div><label>Shakepay CSV</label><input id="shakepayFile" type="file" accept=".csv,text/csv"></div>
      <div><label>&nbsp;</label><button id="analyzeShakepay" type="button">Analyse Shakepay</button></div>
      <div></div>
    </div>
    <div id="shakepayResult" style="margin-top:10px"></div>
  </section>
  <section class="panel" id="sec-rules">
    <h2>DCA / Auto-Buy Rules (selected currency)</h2>
    <div class="grid g6">
      <div>
        <label>Start Date</label>
        <div class="dateWrap"><input id="rDate" type="date" value="2021-10-31"><button id="pickRDate" type="button">üìÖ</button></div>
      </div>
      <div>
        <label>End Date</label>
        <div class="dateWrap"><input id="rEnd" type="date" disabled><button id="pickREnd" type="button" disabled>üìÖ</button></div>
        <label class="small" style="margin-top:6px"><input id="rOngoing" type="checkbox" checked> Ongoing (no end date)</label>
      </div>
      <div><label>Amount (CAD)</label><input id="rAmt" type="number" min="0" step="0.01" value="15"></div>
      <div><label>Frequency</label><select id="rFreq"><option value="daily">Daily</option><option value="weekly">Weekly</option><option value="biweekly">Bi-weekly</option><option value="monthly">Monthly</option></select></div>
      <div id="rAssetWrap"><label>Asset</label><select id="rAsset"><option value="BTC">BTC</option><option value="ETH">ETH</option></select></div>
      <div><label>&nbsp;</label><button id="addRule">Add / Update Rule</button></div>
      <div><label>&nbsp;</label><button id="clearRules">Clear Rules</button></div>
    </div>
    <div class="actions" style="margin-top:10px">
      <button id="normalizeRules" type="button">Normalize Rules (remove duplicates)</button>
    </div>
    <div id="ruleList" class="list" style="margin-top:10px"></div>
  </section>

  <section class="panel" id="sec-dips">
    <h2>Dip Buys (CAD)</h2>
    <p class="small">Optional override fields let you use your books exactly (price + BTC or sats).</p>
    <div class="grid g5">
      <div>
        <label>Date</label>
        <div class="dateWrap"><input id="dDate" type="date"><button id="pickDDate" type="button">üìÖ</button></div>
      </div>
      <div><label>Amount Paid (CAD)</label><input id="dAmt" type="number" min="0" step="0.01" placeholder="1000"></div>
      <div><label>Book Price (selected currency per unit, optional)</label><input id="dPrice" type="number" min="0" step="0.01" placeholder="90000"></div>
      <div><label>Received Amount (optional)</label><input id="dQty" type="number" min="0" step="0.00000001" placeholder="0.01111112"></div>
      <div><label>Received Unit</label><select id="dQtyUnit"><option value="btc">BTC</option><option value="sats">sats</option><option value="eth">ETH</option></select></div>
    </div>
    <div class="actions" style="margin-top:10px">
      <button id="addDip">Add Dip Buy</button>
      <button id="saveDipEdit" style="display:none;">Save Dip Edit</button>
      <button id="cancelDipEdit" style="display:none;">Cancel Edit</button>
      <button id="clearDips">Clear Dip Buys</button>
    </div>
    <div class="grid g3" style="margin-top:10px">
      <div><label>Min CAD for dip extraction</label><input id="dipMinCad" type="number" min="0" step="1" value="250"></div>
      <div><label><input id="replaceDipsOnExtract" type="checkbox" checked> Replace existing dips when extracting</label></div>
      <div><label>&nbsp;</label><button id="extractDipsFromShakepay" type="button">Extract Dips from Uploaded Shakepay CSV</button></div>
    </div>
    <div class="actions" style="margin-top:10px">
      <span class="small">Sort dips:</span>
      <button id="sortDipDate" class="chip" type="button">Date</button>
      <button id="sortDipBestRoi" class="chip" type="button">Best ROI</button>
      <button id="sortDipWorstRoi" class="chip" type="button">Worst ROI</button>
      <button id="sortDipBiggestPnl" class="chip" type="button">Best PnL</button>
      <button id="sortDipWorstPnl" class="chip" type="button">Worst PnL</button>
    </div>
    <div id="dipList" class="list" style="margin-top:10px"></div>
  </section>

  <section class="panel" id="sec-returns">
    <h2>Returns Calculator</h2>
    <div class="grid g3">
      <div><label>Price source</label><input value="CryptoCompare historical daily" disabled></div>
      <div><label>FX (CAD per USD, used for CAD‚ÜîUSD conversion)</label><input id="fx" type="number" min="0.5" step="0.0001" value="1.35"></div>
      <div><label>&nbsp;</label><button id="calc">Update Calculated Returns</button></div>
    </div>
    <div class="grid g3" style="margin-top:10px">
      <div>
        <label>Calculation Mode</label>
        <select id="calcMode">
          <option value="rules">Rules only</option>
          <option value="shakepay" selected>Shakepay only</option>
          <option value="hybrid">Hybrid (advanced)</option>
        </select>
      </div>
      <div><label>&nbsp;</label><span class="small">Rules only = DCA+Dip rules. Shakepay only = imported buys only. Hybrid = both (may overlap).</span></div>
      <div></div>
    </div>
    <p id="status" class="small" style="margin-top:10px">Ready.</p>
    <div id="result" style="margin-top:10px"></div>
  </section>


  <section class="panel">
    <h2>Asset Flow Summary (Shakepay CSV)</h2>
    <p class="small">Visibility only: buys, rewards, received, sent, and net flow from imported Shakepay rows (based on selected asset mode).</p>
    <div id="flowResult"></div>
  </section>


  <section class="panel" id="sec-donate">
    <h2>Support / Donate</h2>
    <p class="small">If this tool helped, tips are appreciated üôè</p>
    <div class="grid g4">
      <div class="item"><div><b>Bitcoin (on-chain)</b></div><div class="small" id="donBtc">bc1qyccdm5ugyt2tn96425v5vyj2u4zsf09h0anr08</div><button class="chip" type="button" onclick="copyDonate('donBtc')">Copy</button></div>
      <div class="item"><div><b>Lightning</b></div><div class="small" id="donLn">crypt0jt@shakepay.me</div><button class="chip" type="button" onclick="copyDonate('donLn')">Copy</button></div>
      <div class="item"><div><b>ETH</b></div><div class="small" id="donEth">crypt0jt.eth</div><button class="chip" type="button" onclick="copyDonate('donEth')">Copy</button></div>
      <div class="item"><div><b>Shakepay handle</b></div><div class="small" id="donSp">crypt0jt</div><button class="chip" type="button" onclick="copyDonate('donSp')">Copy</button></div>
    </div>
  </section>

  <div id="mobileStickyActions">
    <button type="button" id="stickyAnalyze">Analyse</button>
    <button type="button" id="stickyCalc">Update</button>
    <button type="button" id="stickyClear">Clear</button>
  </div>

</div>

<dialog id="helpDialog">
  <h3>Quick Guide</h3>
  <ol>
    <li><b>Pick mode first:</b> Bitcoin-only or BTC+ETH, then CAD or USD quote.</li>
    <li><b>If you use Shakepay:</b> upload <code>crypto_transactions_summary.csv</code> and click Analyse. The app auto-updates returns.</li>
    <li><b>DCA rules:</b> add start date, optional end date, amount, frequency, and asset (asset shown in BTC+ETH mode).</li>
    <li><b>Dip buys:</b> add/edit manual dips, or extract BTC dips from uploaded Shakepay by threshold.</li>
    <li><b>Sell-aware model:</b> sales are included in overall totals as simple proceeds/units adjustments. Exact realized PnL is approximate without FIFO/LIFO lot accounting and full transfer history.</li>
    <li><b>Use Update Calculated Returns</b> after changing rules/dips/import settings.</li>
  </ol>
  <p class="small">Privacy: data is processed client-side and stored in this browser profile (localStorage). Clear All wipes local state.</p>
  <div class="actions"><button id="closeHelp" type="button">Close</button></div>
</dialog>

<script>
const SATS = 100000000;
const defaultRules = [];
const jget = (k, fallback) => {
  try {
    const v = JSON.parse(localStorage.getItem(k) || 'null');
    return v ?? fallback;
  } catch {
    return fallback;
  }
};

const rules = (jget('btc.rules', structuredClone(defaultRules)) || [])
  .filter(r => r && typeof r === 'object')
  .map(r => ({date: String(r.date || '').slice(0,10), end: String(r.end || '').slice(0,10), amount: Number(r.amount||0), freq: String(r.freq||'daily'), asset: String(r.asset||'BTC').toUpperCase()}))
  .filter(r => r.date && r.amount > 0 && (r.asset==='BTC' || r.asset==='ETH'));
const dips = (jget('btc.dips', []) || [])
  .filter(d => d && typeof d === 'object')
  .map(d => ({date: String(d.date || '').slice(0,10), amount: Number(d.amount||0), price: d.price==null?null:Number(d.price), asset: String(d.asset||'BTC').toUpperCase(), btc: d.btc==null?null:Number(d.btc), eth: d.eth==null?null:Number(d.eth), sats: d.sats==null?null:Number(d.sats)}))
  .filter(d => d.date && d.amount > 0);
const shakepayBuyLots = (jget('btc.shakepayBuyLots', []) || [])
  .filter(l => l && typeof l === 'object')
  .map(l => ({date: String(l.date || '').slice(0,10), amount: Number(l.amount||0), ccy: String(l.ccy||'CAD').toUpperCase(), btc: Number(l.btc||0), asset: String(l.asset||'BTC').toUpperCase(), price: l.price==null?null:Number(l.price)}))
  .filter(l => l.date && l.amount > 0);
let editingDipIndex = null;
let dipSortMode = 'date';

const $ = id => document.getElementById(id);
const fmt = n => Number(n).toLocaleString(undefined,{maximumFractionDigits:2});
const dayKey = d => new Date(d).toISOString().slice(0,10);

function jumpTo(id){
  const el = $(id);
  if (!el) return;
  el.scrollIntoView({behavior:'smooth', block:'start'});
}
const dateObj = ymd => new Date(ymd+'T00:00:00');
const save = () => { localStorage.setItem('btc.rules', JSON.stringify(rules)); localStorage.setItem('btc.dips', JSON.stringify(dips)); };
const convertAmount = (amount, from, to, fxCadPerUsd) => {
  if (from === to) return Number(amount);
  if (from === 'CAD' && to === 'USD') return Number(amount) / fxCadPerUsd;
  if (from === 'USD' && to === 'CAD') return Number(amount) * fxCadPerUsd;
  return Number(amount);
};
const esc = (s='') => String(s)
  .replace(/&/g,'&amp;')
  .replace(/</g,'&lt;')
  .replace(/>/g,'&gt;')
  .replace(/"/g,'&quot;')
  .replace(/'/g,'&#39;');

function openPicker(input){ if (input.showPicker) input.showPicker(); else input.focus(); }
function copyDonate(id){
  const txt = (document.getElementById(id)?.textContent || '').trim();
  if (!txt) return;
  navigator.clipboard.writeText(txt)
    .then(()=>{ $('status').textContent = `Copied: ${txt}`; })
    .catch(()=>{ $('status').textContent = 'Copy failed; please copy manually.'; });
}
function getAssetMode(){
  return (document.querySelector('input[name="assetMode"]:checked') || {}).value || 'btc';
}
function getQuoteMode(){
  return (document.querySelector('input[name="quoteMode"]:checked') || {}).value || 'CAD';
}
function applyMode(){
  const mode = getAssetMode();
  const quote = getQuoteMode();
  document.body.classList.remove('mode-btc','mode-bteth');
  const bteth = mode === 'bteth';
  document.body.classList.add(bteth ? 'mode-bteth' : 'mode-btc');
  $('appTitle').textContent = bteth ? `Bitcoin/ETH DCA Calculator (${quote})` : `Bitcoin DCA Calculator (${quote})`;
  $('rAssetWrap').style.display = bteth ? '' : 'none';
  if (!bteth) $('rAsset').value = 'BTC';
}
const savedModeRaw = localStorage.getItem('btc.assetMode') || 'btc';
const savedQuoteRaw = localStorage.getItem('btc.quoteMode') || 'CAD';
const savedMode = ['btc','bteth'].includes(savedModeRaw) ? savedModeRaw : 'btc';
const savedQuote = ['CAD','USD'].includes(savedQuoteRaw) ? savedQuoteRaw : 'CAD';
(document.querySelector(`input[name="assetMode"][value="${savedMode}"]`) || document.querySelector('input[name="assetMode"][value="btc"]')).checked = true;
(document.querySelector(`input[name="quoteMode"][value="${savedQuote}"]`) || document.querySelector('input[name="quoteMode"][value="CAD"]')).checked = true;
applyMode();
document.querySelectorAll('input[name="assetMode"]').forEach(el=>el.addEventListener('change', async ()=>{
  localStorage.setItem('btc.assetMode', getAssetMode());
  applyMode();
  if (($('shakepayFile').files && $('shakepayFile').files[0]) || localStorage.getItem('btc.shakepayCsvText')) {
    try { await $('analyzeShakepay').onclick(); } catch {}
  }
}));
document.querySelectorAll('input[name="quoteMode"]').forEach(el=>el.addEventListener('change', async ()=>{
  localStorage.setItem('btc.quoteMode', getQuoteMode());
  applyMode();
  if (($('shakepayFile').files && $('shakepayFile').files[0]) || localStorage.getItem('btc.shakepayCsvText')) {
    try { await $('analyzeShakepay').onclick(); } catch {}
  }
}));

$('pickRDate').onclick = () => openPicker($('rDate'));
$('pickREnd').onclick = () => { if (!$('rEnd').disabled) openPicker($('rEnd')); };
$('pickDDate').onclick = () => openPicker($('dDate'));
$('rOngoing').addEventListener('change', ()=>{
  const off = !$('rOngoing').checked;
  $('rEnd').disabled = !off;
  $('pickREnd').disabled = !off;
  if (!off) $('rEnd').value = '';
});
$('sortDipDate').onclick = () => { dipSortMode = 'date'; render(); };
$('sortDipBestRoi').onclick = () => { dipSortMode = 'bestRoi'; render(); };
$('sortDipWorstRoi').onclick = () => { dipSortMode = 'worstRoi'; render(); };
$('sortDipBiggestPnl').onclick = () => { dipSortMode = 'biggestPnl'; render(); };
$('sortDipWorstPnl').onclick = () => { dipSortMode = 'worstPnl'; render(); };
$('helpBtn').onclick = () => $('helpDialog').showModal();
$('closeHelp').onclick = () => $('helpDialog').close();
$('jumpShakepay')?.addEventListener('click', ()=>jumpTo('sec-shakepay'));
$('jumpRules')?.addEventListener('click', ()=>jumpTo('sec-rules'));
$('jumpDips')?.addEventListener('click', ()=>jumpTo('sec-dips'));
$('jumpReturns')?.addEventListener('click', ()=>jumpTo('sec-returns'));
$('stickyAnalyze')?.addEventListener('click', ()=>$('analyzeShakepay').click());
$('stickyCalc')?.addEventListener('click', ()=>$('calc').click());
$('stickyClear')?.addEventListener('click', ()=>$('clearAll').click());

if (window.matchMedia('(max-width: 640px)').matches) {
  document.querySelectorAll('.panel > h2').forEach((h2) => {
    const panel = h2.parentElement;
    if (!panel || panel.id === 'sec-shakepay') return;
    panel.classList.add('collapsed');
    h2.addEventListener('click', () => panel.classList.toggle('collapsed'));
  });
}

function render(){
  rules.sort((a,b)=>a.date.localeCompare(b.date));
  $('ruleList').innerHTML = rules.map((r,i)=>`<div class="item">From <b>${esc(r.date)}</b>${r.end?` to <b>${esc(r.end)}</b>`:' to <b>now</b>'}: <b>$${fmt(r.amount)} / ${esc(r.freq||'daily')} / ${esc(r.asset||'BTC')}</b> <button onclick="delRule(${i})" style="width:auto;margin-left:8px">remove</button></div>`).join('') || '<p class="small">No rules.</p>';

  const lastPrice = Number(localStorage.getItem('btc.lastCurrentPriceCad') || 0);
  const lastEthPrice = Number(localStorage.getItem('btc.lastCurrentEthPriceCad') || 0);
  const metric = (d) => {
    const asset = (d.asset || 'BTC').toUpperCase();
    const qty = asset === 'ETH'
      ? (d.eth ? Number(d.eth) : (d.price ? Number(d.amount)/Number(d.price) : 0))
      : (d.btc ? Number(d.btc) : (d.sats ? Number(d.sats)/SATS : (d.price ? Number(d.amount)/Number(d.price) : 0)));
    const pNow = asset === 'ETH' ? lastEthPrice : lastPrice;
    const valNow = pNow > 0 ? qty * pNow : 0;
    const pnl = valNow - Number(d.amount || 0);
    const roi = Number(d.amount) > 0 ? (pnl / Number(d.amount)) * 100 : 0;
    return {qty, valNow, pnl, roi, asset};
  };

  if (dipSortMode === 'date') dips.sort((a,b)=>a.date.localeCompare(b.date));
  if (dipSortMode === 'bestRoi') dips.sort((a,b)=>metric(b).roi - metric(a).roi);
  if (dipSortMode === 'worstRoi') dips.sort((a,b)=>metric(a).roi - metric(b).roi);
  if (dipSortMode === 'biggestPnl') dips.sort((a,b)=>metric(b).pnl - metric(a).pnl);
  if (dipSortMode === 'worstPnl') dips.sort((a,b)=>metric(a).pnl - metric(b).pnl);

  $('dipList').innerHTML = dips.map((d,i)=>{
    const m = metric(d);
    const asset = m.asset;
    const detail = asset === 'ETH'
      ? (d.eth ? `${Number(d.eth).toFixed(8)} ETH` : (d.price ? `at $${fmt(d.price)} / ETH` : 'uses market daily avg'))
      : (d.btc ? `${Number(d.btc).toFixed(8)} BTC` : (d.sats ? `${Number(d.sats).toLocaleString()} sats` : (d.price ? `at $${fmt(d.price)} / BTC` : 'uses market daily avg')));
    let perf = '';
    if (m.qty > 0 && m.valNow > 0) {
      perf = ` <span class="small">| PnL: <b class="${m.pnl>=0?'ok':'warn'}">$${fmt(m.pnl)}</b> | ROI: <b class="${m.roi>=0?'ok':'warn'}">${m.roi.toFixed(2)}%</b></span>`;
    }
    return `<div class="item">${esc(d.date)} [${asset}]: <b>$${fmt(d.amount)}</b> ‚Äî ${esc(detail)}${perf}<button onclick="editDip(${i})" style="width:auto;margin-left:8px">edit</button><button onclick="delDip(${i})" style="width:auto;margin-left:8px">remove</button></div>`;
  }).join('') || '<p class="small">No dip buys.</p>';
}
window.delRule = i => { rules.splice(i,1); save(); render(); };
window.delDip = i => { dips.splice(i,1); save(); render(); };
window.editDip = i => {
  const d = dips[i];
  if (!d) return;
  editingDipIndex = i;
  $('dDate').value = d.date || '';
  $('dAmt').value = d.amount ?? '';
  $('dPrice').value = d.price ?? '';
  $('dQty').value = d.eth ?? (d.btc ?? (d.sats ?? ''));
  $('dQtyUnit').value = d.eth ? 'eth' : (d.btc ? 'btc' : (d.sats ? 'sats' : 'btc'));
  $('addDip').style.display = 'none';
  $('saveDipEdit').style.display = '';
  $('cancelDipEdit').style.display = '';
};

function isRuleHit(rule, d){
  const start = dateObj(rule.date);
  const end = rule.end ? dateObj(rule.end) : null;
  if (d < start) return false;
  if (end && d > end) return false;
  const diffDays = Math.floor((d - start) / 86400000);
  const freq = rule.freq || 'daily';
  if (freq === 'daily') return true;
  if (freq === 'weekly') return diffDays % 7 === 0;
  if (freq === 'biweekly') return diffDays % 14 === 0;
  if (freq === 'monthly') {
    const sd = start.getDate();
    const md = d.getDate();
    const lastDay = new Date(d.getFullYear(), d.getMonth()+1, 0).getDate();
    return md === sd || (sd > lastDay && md === lastDay);
  }
  return true;
}

function dcaAmountOnDate(dateStr, asset='BTC'){
  const d = dateObj(dateStr);
  const applied = rules.filter(r=>r.asset===asset && r.date<=dateStr && (!r.end || r.end>=dateStr)).sort((a,b)=>a.date.localeCompare(b.date)).pop();
  if (!applied) return 0;
  return isRuleHit(applied, d) ? Number(applied.amount) : 0;
}

async function fetchCC(tsym, limit=2000, fsym='BTC'){
  const safeTsym = ['CAD','USD'].includes(String(tsym||'').toUpperCase()) ? String(tsym).toUpperCase() : 'CAD';
  const safeFsym = ['BTC','ETH'].includes(String(fsym||'').toUpperCase()) ? String(fsym).toUpperCase() : 'BTC';
  const safeLimit = Math.max(1, Math.min(Number(limit)||2000, 2000));
  const url = `https://min-api.cryptocompare.com/data/v2/histoday?fsym=${safeFsym}&tsym=${safeTsym}&limit=${safeLimit}`;
  const ac = new AbortController();
  const timer = setTimeout(() => ac.abort(), 12000);
  let res;
  try {
    res = await fetch(url, { signal: ac.signal });
  } catch (e) {
    if (e.name === 'AbortError') throw new Error('Price API timeout');
    throw e;
  } finally {
    clearTimeout(timer);
  }
  if (!res.ok) throw new Error(`Price API failed: ${res.status}`);
  const json = await res.json();
  if (json.Response !== 'Success') throw new Error(json.Message || 'Price API error');
  if (!json?.Data?.Data || !Array.isArray(json.Data.Data)) throw new Error('Price API malformed response');
  return json.Data.Data;
}

function toDailyMapCC(rows, fx=1){
  const m = {};
  const f = Number(fx);
  const safeFx = Number.isFinite(f) && f > 0 ? f : 1;
  for (const r of rows) {
    const t = Number(r?.time);
    const o = Number(r?.open), h = Number(r?.high), l = Number(r?.low), c = Number(r?.close);
    if (!Number.isFinite(t) || !Number.isFinite(o) || !Number.isFinite(h) || !Number.isFinite(l) || !Number.isFinite(c)) continue;
    if (o <= 0 || h <= 0 || l <= 0 || c <= 0) continue;
    if (h < l) continue;
    const avgUsd = (o + h + l + c) / 4;
    if (!Number.isFinite(avgUsd) || avgUsd <= 0 || avgUsd > 10_000_000) continue;
    const k = new Date(t*1000).toISOString().slice(0,10);
    m[k] = avgUsd * safeFx;
  }
  return m;
}

function priceForDate(map, d){
  const x = new Date(d);
  for (let i=0;i<10;i++) {
    const k = dayKey(x);
    if (map[k]) return map[k];
    x.setDate(x.getDate()-1);
  }
  return null;
}

function linePath(points, minY, maxY, w, h, pad){
  if (!points.length) return '';
  const span = (maxY - minY) || 1;
  const stepX = points.length > 1 ? (w - pad*2) / (points.length - 1) : 0;
  return points.map((v,i)=>{
    const x = pad + i*stepX;
    const y = h - pad - ((v - minY)/span) * (h - pad*2);
    return `${i===0?'M':'L'}${x.toFixed(2)},${y.toFixed(2)}`;
  }).join(' ');
}

function buildRoiPnlChart(series){
  if (!series?.length) return '';
  const w=980, h=300, padL=56, padR=56, padT=16, padB=34;
  const innerW = w - padL - padR;
  const innerH = h - padT - padB;

  const pnlVals = series.map(s=>Number(s.pnl||0));
  const roiVals = series.map(s=>Number(s.roi||0));
  const btcVals = series.map(s=>Number(s.btcPrice||0)).filter(v=>Number.isFinite(v) && v>0);

  const minPnl = Math.min(0, ...pnlVals);
  const maxPnl = Math.max(0, ...pnlVals);
  const minRoi = Math.min(0, ...roiVals);
  const maxRoi = Math.max(0, ...roiVals);

  const pnlPath = linePath(pnlVals, minPnl, maxPnl, w-padR, h-padB, padL);
  const roiPath = linePath(roiVals, minRoi, maxRoi, w-padR, h-padB, padL);

  let btcPath = '';
  if (btcVals.length) {
    const minB = Math.min(...btcVals), maxB = Math.max(...btcVals);
    const points = series.map(s=>Number(s.btcPrice||0));
    btcPath = linePath(points, minB, maxB, w-padR, h-padB, padL);
  }

  const yForPnl = (v)=> (h-padB) - ((v-minPnl)/((maxPnl-minPnl)||1))*innerH;
  const yForRoi = (v)=> (h-padB) - ((v-minRoi)/((maxRoi-minRoi)||1))*innerH;
  const xForIndex = (i)=> padL + (series.length>1 ? (i*(innerW/(series.length-1))) : 0);

  const zeroPnlY = yForPnl(0);
  const ticks = [0, Math.floor((series.length-1)/2), series.length-1].filter((v,i,a)=>a.indexOf(v)===i && v>=0);
  const tickLabels = ticks.map(i=>{
    const d = new Date(series[i].date+'T00:00:00');
    const label = d.toLocaleDateString('en-CA',{year:'numeric',month:'short'});
    return `<text x="${xForIndex(i).toFixed(2)}" y="${h-8}" text-anchor="middle" fill="#8fa2d6" font-size="11">${label}</text>`;
  }).join('');

  const last = series[series.length-1];
  const quote = getQuoteMode();
  return `
    <div class="chartWrap">
      <div class="small"><b>Performance Trend</b> ‚Äî PnL (left), ROI% (right), BTC price (overlay)</div>
      <svg viewBox="0 0 ${w} ${h}" width="100%" height="260" role="img" aria-label="PnL, ROI, and BTC price trend chart">
        <rect x="${padL}" y="${padT}" width="${innerW}" height="${innerH}" fill="rgba(8,14,32,.35)" stroke="#2b3d69" />
        <line x1="${padL}" y1="${zeroPnlY.toFixed(2)}" x2="${w-padR}" y2="${zeroPnlY.toFixed(2)}" stroke="#33406a" stroke-dasharray="4 4" />
        <path d="${btcPath}" fill="none" stroke="#f7931a" stroke-opacity=".5" stroke-width="2" stroke-dasharray="5 4" />
        <path d="${pnlPath}" fill="none" stroke="#60a5fa" stroke-width="3" stroke-linecap="round" />
        <path d="${roiPath}" fill="none" stroke="#22c55e" stroke-width="3" stroke-linecap="round" />
        ${tickLabels}
        <text x="8" y="${padT+12}" fill="#8fa2d6" font-size="11">PnL (${quote})</text>
        <text x="${w-8}" y="${padT+12}" text-anchor="end" fill="#8fa2d6" font-size="11">ROI (%)</text>
        <text x="8" y="${(h-padB).toFixed(2)}" fill="#8fa2d6" font-size="11">$${fmt(minPnl)}</text>
        <text x="8" y="${(padT+12).toFixed(2)}" fill="#8fa2d6" font-size="11">$${fmt(maxPnl)}</text>
        <text x="${w-8}" y="${(h-padB).toFixed(2)}" text-anchor="end" fill="#8fa2d6" font-size="11">${minRoi.toFixed(1)}%</text>
        <text x="${w-8}" y="${(padT+12).toFixed(2)}" text-anchor="end" fill="#8fa2d6" font-size="11">${maxRoi.toFixed(1)}%</text>
      </svg>
      <div class="chartLegend small">
        <span><span class="dot" style="background:#60a5fa"></span>PnL (last: $${fmt(Number(last.pnl||0))})</span>
        <span><span class="dot" style="background:#22c55e"></span>ROI (last: ${Number(last.roi||0).toFixed(2)}%)</span>
        <span><span class="dot" style="background:#f7931a"></span>BTC price overlay (normalized)</span>
      </div>
      <div class="small" style="margin-top:6px">Note: BTC overlay is normalized for trend context only (not same axis units).</div>
    </div>`;
}

$('addRule').onclick = () => {
  const date = $('rDate').value; const end = $('rOngoing').checked ? '' : ($('rEnd').value || ''); const amount = Number($('rAmt').value); const freq = $('rFreq').value; const asset = $('rAsset').value;
  if (!date || amount<=0) return alert('Need valid start date + amount.');
  if (end && end < date) return alert('End date must be on/after start date.');
  const i = rules.findIndex(r=>r.date===date && (r.end||'')===end && (r.asset||'BTC')===asset);
  if (i>=0) rules[i] = {date, end, amount, freq, asset}; else rules.push({date, end, amount, freq, asset});
  save(); render();
};
$('clearRules').onclick = () => { rules.splice(0, rules.length); save(); render(); };
$('normalizeRules').onclick = () => {
  if (!rules.length) return;
  rules.sort((a,b)=>a.date.localeCompare(b.date));
  const out = [];
  for (const r of rules) {
    const amt = Number(r.amount);
    const freq = r.freq || 'daily';
    const asset = r.asset || 'BTC';
    const end = r.end || '';
    const prev = out[out.length-1];
    if (!prev || Number(prev.amount) !== amt || (prev.freq||'daily') !== freq || (prev.asset||'BTC') !== asset || (prev.end||'') !== end) out.push({date:r.date, end, amount:amt, freq, asset});
  }
  rules.splice(0, rules.length, ...out);
  save(); render();
  $('status').textContent = `Normalized rules: ${out.length} effective change(s).`;
};
$('clearAll').onclick = () => {
  if (!confirm('Clear all rules, dip buys, saved inputs, and results?')) return;
  rules.splice(0, rules.length);
  dips.splice(0, dips.length);
  localStorage.removeItem('btc.rules');
  localStorage.removeItem('btc.dips');
  localStorage.removeItem('btc.shakepayBuyLots');
  localStorage.removeItem('btc.shakepayCsvText');
  localStorage.removeItem('btc.sellBtcUnits');
  localStorage.removeItem('btc.sellEthUnits');
  localStorage.removeItem('btc.sellProceeds');
  shakepayBuyLots.splice(0, shakepayBuyLots.length);
  $('result').innerHTML = '';
  $('shakepayResult').innerHTML = '';
  $('flowResult').innerHTML = '';
  if ($('csvResult')) $('csvResult').innerHTML = '';
  if ($('shakepayFile')) $('shakepayFile').value = '';
  localStorage.removeItem('btc.lastCurrentPriceCad');
  localStorage.removeItem('btc.lastCurrentEthPriceCad');
  $('status').textContent = 'Cleared everything (including Shakepay import details).';
  resetDipEditor();
  render();
};

function resetDipEditor(){
  editingDipIndex = null;
  $('dDate').value = '';
  $('dAmt').value = '';
  $('dPrice').value = '';
  $('dQty').value = '';
  $('dQtyUnit').value = 'btc';
  $('addDip').style.display = '';
  $('saveDipEdit').style.display = 'none';
  $('cancelDipEdit').style.display = 'none';
}

function readDipForm(){
  const date = $('dDate').value;
  const amount = Number($('dAmt').value || 0);
  const price = Number($('dPrice').value || 0);
  const qty = Number($('dQty').value || 0);
  const qtyUnit = $('dQtyUnit').value;
  if (!date || amount<=0) throw new Error('Need dip date + amount.');
  const btc = qty > 0 && qtyUnit === 'btc' ? qty : null;
  const eth = qty > 0 && qtyUnit === 'eth' ? qty : null;
  const sats = qty > 0 && qtyUnit === 'sats' ? qty : null;
  const asset = eth ? 'ETH' : 'BTC';
  return {date, amount, price: price||null, asset, btc, eth, sats};
}

$('addDip').onclick = () => {
  try {
    dips.push(readDipForm());
    save(); render(); resetDipEditor();
  } catch (e) { alert(e.message); }
};

$('saveDipEdit').onclick = () => {
  try {
    if (editingDipIndex == null || !dips[editingDipIndex]) return alert('No dip selected for edit.');
    dips[editingDipIndex] = readDipForm();
    save(); render(); resetDipEditor();
  } catch (e) { alert(e.message); }
};

$('cancelDipEdit').onclick = () => resetDipEditor();
$('clearDips').onclick = () => { dips.length = 0; save(); render(); resetDipEditor(); };

$('extractDipsFromShakepay').onclick = () => {
  const minCad = Number($('dipMinCad').value || 250);
  const replace = $('replaceDipsOnExtract').checked;
  if (!shakepayBuyLots.length) return alert('No Shakepay buy lots loaded. Upload and Analyse Shakepay first.');
  if (replace) dips.splice(0, dips.length);

  let added = 0;
  for (const lot of shakepayBuyLots) {
    if ((lot.asset || 'BTC') !== 'BTC') continue;
    if (Number(lot.amount) < minCad) continue;
    const key = `BTC|${lot.date}|${Number(lot.amount).toFixed(2)}|${Number(lot.btc||0).toFixed(8)}`;
    const exists = dips.some(d => `BTC|${d.date}|${Number(d.amount).toFixed(2)}|${Number(d.btc||0).toFixed(8)}` === key);
    if (exists) continue;
    const quote = getQuoteMode();
    const amountInQuote = convertAmount(Number(lot.amount), String(lot.ccy||'CAD').toUpperCase(), quote, Number($('fx').value||1.35));
    dips.push({date: lot.date, amount: amountInQuote, price: lot.price || null, btc: Number(lot.btc)||null, sats: null});
    added++;
  }
  save(); render();
  $('status').textContent = `Extracted ${added} dip buy(s) from Shakepay lots using threshold $${fmt(minCad)}.`;
};

$('calc').onclick = async () => {
  const status = $('status');
  status.textContent = 'Fetching market history‚Ä¶';

  try {
    const quote = getQuoteMode();
    const fx = Number($('fx').value || 1.35);

    const assetMode = getAssetMode();
    const activeAssets = assetMode === 'bteth' ? ['BTC','ETH'] : ['BTC'];

    const maps = {};
    let sourceLabel = '';
    for (const a of activeAssets) {
      const rows = await fetchCC(quote, 2000, a);
      maps[a] = toDailyMapCC(rows, 1);
    }
    sourceLabel = `CryptoCompare ${activeAssets.join('/')} ${quote} (OHLC avg/day)`;
    const map = maps['BTC'];

    const mode = $('calcMode').value;
    const useRules = mode === 'rules' || mode === 'hybrid';
    const useShakepayLots = mode === 'shakepay' || mode === 'hybrid';
    let invested=0, btc=0, dcaInvested=0, dipInvested=0, skipped=0;
    let dcaBtc=0, dipBtc=0, shakepayBtc=0, shakepayInvested=0;
    let sellProceeds = Number(localStorage.getItem('btc.sellProceeds') || 0);
    let sellBtcUnits = Number(localStorage.getItem('btc.sellBtcUnits') || 0);
    let sellEthUnits = Number(localStorage.getItem('btc.sellEthUnits') || 0);
    const assetStats = { BTC:{invested:0, qty:0}, ETH:{invested:0, qty:0} };

    if (useRules && rules.length) {
      const start = rules.map(r=>r.date).sort()[0];
      for (let d=dateObj(start), end=new Date(); d<=end; d.setDate(d.getDate()+1)) {
        const k = dayKey(d);
        const amountBtc = dcaAmountOnDate(k, 'BTC');
        const amountEth = dcaAmountOnDate(k, 'ETH');

        if (amountBtc > 0) {
          const pxB = priceForDate(maps['BTC'], d);
          if (!pxB) { skipped++; } else {
            const gotB = amountBtc / pxB;
            invested += amountBtc; dcaInvested += amountBtc; btc += gotB; dcaBtc += gotB;
            assetStats.BTC.invested += amountBtc; assetStats.BTC.qty += gotB;
          }
        }

        if (amountEth > 0) {
          const pxE = priceForDate(maps['ETH'] || maps['BTC'], d);
          if (!pxE) { skipped++; } else {
            const gotE = amountEth / pxE;
            invested += amountEth; dcaInvested += amountEth;
            assetStats.ETH.invested += amountEth; assetStats.ETH.qty += gotE;
          }
        }
      }
    }

    if (useRules) for (const dip of dips) {
      const asset = (dip.asset || 'BTC').toUpperCase();
      let got = 0;
      if (asset === 'ETH') {
        if (dip.eth) got = Number(dip.eth);
        else if (dip.price) got = Number(dip.amount)/Number(dip.price);
        else {
          const px = priceForDate(maps['ETH'] || maps['BTC'], dateObj(dip.date));
          if (!px) { skipped++; continue; }
          got = Number(dip.amount)/px;
        }
      } else {
        if (dip.btc) got = Number(dip.btc);
        else if (dip.sats) got = Number(dip.sats)/SATS;
        else if (dip.price) got = Number(dip.amount)/Number(dip.price);
        else {
          const px = priceForDate(maps['BTC'], dateObj(dip.date));
          if (!px) { skipped++; continue; }
          got = Number(dip.amount)/px;
        }
      }
      invested += Number(dip.amount);
      dipInvested += Number(dip.amount);
      if (asset === 'BTC') { btc += got; dipBtc += got; }
      assetStats[asset] = assetStats[asset] || {invested:0, qty:0};
      assetStats[asset].invested += Number(dip.amount);
      assetStats[asset].qty += got;
    }

    if (useShakepayLots && shakepayBuyLots.length) {
      const dipKeys = new Set(dips.map(d => `BTC|${d.date}|${Number(d.amount).toFixed(2)}|${(Number(d.btc||0)).toFixed(8)}`));
      let lotsIncluded = 0;
      for (const lot of shakepayBuyLots) {
        const asset = (lot.asset || 'BTC').toUpperCase();
        const key = `${asset}|${lot.date}|${Number(lot.amount).toFixed(2)}|${(Number(lot.btc||0)).toFixed(8)}`;
        if (asset === 'BTC' && dipKeys.has(key)) continue; // avoid double-count if same BTC buy already imported as dip
        const amountInQuote = convertAmount(Number(lot.amount), String(lot.ccy||'CAD').toUpperCase(), quote, fx);
        invested += amountInQuote;
        const qty = Number(lot.btc || 0);
        if (asset === 'BTC') shakepayBtc += qty;
        shakepayInvested += amountInQuote;
        assetStats[asset] = assetStats[asset] || {invested:0, qty:0};
        assetStats[asset].invested += amountInQuote;
        assetStats[asset].qty += qty;
        btc += asset === 'BTC' ? qty : 0;
        lotsIncluded++;
      }
      if (lotsIncluded) status.textContent = `Included ${lotsIncluded} Shakepay buy lot(s) from upload.`;
      if (mode === 'hybrid' && rules.length && lotsIncluded) status.textContent += ' Warning: Hybrid mode may overlap DCA rules and imported buys.';
    }

    const hasRuleInputs = rules.length || dips.length;
    const hasShakepayInputs = shakepayBuyLots.length;
    if ((useRules && !hasRuleInputs) && (useShakepayLots && !hasShakepayInputs)) {
      throw new Error('No inputs for selected mode. Add rules/dips and/or import Shakepay first.');
    }
    if (useRules && !useShakepayLots && !hasRuleInputs) {
      throw new Error('Rules only mode selected, but no rules/dips found.');
    }
    if (useShakepayLots && !useRules && !hasShakepayInputs) {
      throw new Error('Shakepay only mode selected, but no imported Shakepay buys found.');
    }

    const current = priceForDate(maps['BTC'], new Date());
    if (!current) throw new Error('Could not get recent BTC price from source.');
    const currentEth = maps['ETH'] ? priceForDate(maps['ETH'], new Date()) : null;
    localStorage.setItem('btc.lastCurrentPriceCad', String(current));

    if (useShakepayLots) {
      assetStats.BTC.qty = Math.max(0, assetStats.BTC.qty - sellBtcUnits);
      assetStats.ETH.qty = Math.max(0, assetStats.ETH.qty - sellEthUnits);
    } else {
      sellProceeds = 0;
    }

    const value = (assetStats.BTC.qty * current) + (assetStats.ETH.qty * (currentEth || 0));
    const totalValue = value + sellProceeds;
    const pnl = totalValue - invested;
    const roi = invested ? (pnl/invested)*100 : 0;

    const dcaValue = dcaBtc * current;
    const dcaPnl = dcaValue - dcaInvested;
    const dcaRoi = dcaInvested ? (dcaPnl / dcaInvested) * 100 : null;

    const dipValue = dipBtc * current;
    const dipPnl = dipValue - dipInvested;
    const dipRoi = dipInvested ? (dipPnl / dipInvested) * 100 : null;

    // Build a lightweight monthly trend chart for ROI/PnL
    const dateCandidates = [
      ...rules.map(r=>r.date),
      ...dips.map(d=>d.date),
      ...shakepayBuyLots.map(l=>l.date)
    ].filter(Boolean).sort();
    const chartSeries = [];
    if (dateCandidates.length) {
      const startDate = dateObj(dateCandidates[0]);
      const today = new Date();
      const fxNow = Number($('fx').value || 1.35);
      for (let d = new Date(startDate); d <= today; d.setMonth(d.getMonth()+1)) {
        const k = dayKey(d);
        let ci = 0, cBtc=0, cEth=0;

        if (useRules) {
          for (let dd = new Date(startDate); dd <= d; dd.setDate(dd.getDate()+1)) {
            const dk = dayKey(dd);
            const ab = dcaAmountOnDate(dk,'BTC');
            const ae = dcaAmountOnDate(dk,'ETH');
            if (ab>0) { const px=priceForDate(maps['BTC'], dd); if (px){ ci+=ab; cBtc += ab/px; } }
            if (ae>0) { const px=priceForDate(maps['ETH']||maps['BTC'], dd); if (px){ ci+=ae; cEth += ae/px; } }
          }
          for (const dip of dips.filter(x=>x.date<=k)) {
            const asset = (dip.asset||'BTC').toUpperCase();
            let got = 0;
            if (asset==='ETH') {
              if (dip.eth) got = Number(dip.eth);
              else if (dip.price) got = Number(dip.amount)/Number(dip.price);
              else { const px=priceForDate(maps['ETH']||maps['BTC'], dateObj(dip.date)); if (px) got = Number(dip.amount)/px; }
              cEth += got;
            } else {
              if (dip.btc) got = Number(dip.btc);
              else if (dip.sats) got = Number(dip.sats)/SATS;
              else if (dip.price) got = Number(dip.amount)/Number(dip.price);
              else { const px=priceForDate(maps['BTC'], dateObj(dip.date)); if (px) got = Number(dip.amount)/px; }
              cBtc += got;
            }
            ci += Number(dip.amount||0);
          }
        }

        if (useShakepayLots) {
          for (const lot of shakepayBuyLots.filter(x=>x.date<=k)) {
            const asset = (lot.asset||'BTC').toUpperCase();
            ci += convertAmount(Number(lot.amount), String(lot.ccy||'CAD').toUpperCase(), quote, fxNow);
            if (asset==='ETH') cEth += Number(lot.btc||0); else cBtc += Number(lot.btc||0);
          }
          cBtc = Math.max(0, cBtc - sellBtcUnits);
          cEth = Math.max(0, cEth - sellEthUnits);
        }

        const pxB = priceForDate(maps['BTC'], d) || current;
        const pxE = (maps['ETH'] ? (priceForDate(maps['ETH'], d) || currentEth || 0) : 0);
        const cv = cBtc*pxB + cEth*pxE + (useShakepayLots ? sellProceeds : 0);
        const cp = cv - ci;
        const cr = ci ? (cp/ci)*100 : 0;
        chartSeries.push({date:k, pnl:cp, roi:cr, btcPrice:pxB});
      }
    }

    $('status').innerHTML = `Done. Source: <b>${sourceLabel}</b>.`;
    render();
    $('result').innerHTML = `
      <div class="cards">
        <div class="card"><div class="small">Total Invested</div><b>$${fmt(invested)}</b></div>
        <div class="card"><div class="small">From DCA</div><b>$${fmt(dcaInvested)}</b></div>
        <div class="card"><div class="small">From Dip Buys</div><b>$${fmt(dipInvested)}</b></div>
        <div class="card"><div class="small">Estimated BTC</div><b>${assetStats.BTC.qty.toFixed(8)} BTC</b></div>
      </div>
      <div class="cards" style="margin-top:10px">
        <div class="card"><div class="small">Current BTC Price</div><b>$${fmt(current)}</b></div>
        ${assetMode === 'bteth' ? `<div class="card"><div class="small">Current ETH Price</div><b>${currentEth?('$'+fmt(currentEth)):'n/a'}</b></div>` : ''}
        <div class="card"><div class="small">Portfolio Value (current holdings)</div><b>$${fmt(value)}</b></div>
        <div class="card"><div class="small">Realized Sell Proceeds</div><b>$${fmt(sellProceeds)}</b></div>
        <div class="card"><div class="small">Total PnL</div><b class="${pnl>=0?'ok':'warn'}">$${fmt(pnl)}</b></div>
      </div>
      <div class="cards" style="margin-top:10px">
        <div class="card"><div class="small">Total ROI</div><b class="${roi>=0?'ok':'warn'}">${roi.toFixed(2)}%</b></div>
        <div class="card"><div class="small">Total BTC ROI</div><b class="${assetStats.BTC.invested?((((assetStats.BTC.qty*current-assetStats.BTC.invested)/assetStats.BTC.invested*100)>=0)?'ok':'warn'):''}">${assetStats.BTC.invested?(((assetStats.BTC.qty*current-assetStats.BTC.invested)/assetStats.BTC.invested*100).toFixed(2)+'%'):'n/a'}</b></div>
        <div class="card"><div class="small">Total BTC PnL</div><b class="${((assetStats.BTC.qty*current-assetStats.BTC.invested)>=0)?'ok':'warn'}">${assetStats.BTC.invested?('$'+fmt(assetStats.BTC.qty*current-assetStats.BTC.invested)):'n/a'}</b></div>
        ${assetMode === 'bteth' ? `<div class="card"><div class="small">Total ETH ROI</div><b class="${(assetStats.ETH.invested&&currentEth)?((((assetStats.ETH.qty*currentEth-assetStats.ETH.invested)/assetStats.ETH.invested*100)>=0)?'ok':'warn'):''}">${(assetStats.ETH.invested&&currentEth)?(((assetStats.ETH.qty*currentEth-assetStats.ETH.invested)/assetStats.ETH.invested*100).toFixed(2)+'%'):'n/a'}</b></div>` : ''}
      </div>
      ${assetMode === 'bteth' ? `<div class="cards" style="margin-top:10px"><div class="card"><div class="small">Total ETH PnL</div><b class="${((assetStats.ETH.qty*(currentEth||0)-assetStats.ETH.invested)>=0)?'ok':'warn'}">${assetStats.ETH.invested?('$'+fmt(assetStats.ETH.qty*(currentEth||0)-assetStats.ETH.invested)):'n/a'}</b></div></div>` : ''}
      <div class="cards" style="margin-top:10px">
        <div class="card"><div class="small">Total DCA ROI</div><b class="${dcaRoi==null?'':(dcaRoi>=0?'ok':'warn')}">${dcaRoi==null?'n/a':dcaRoi.toFixed(2)+'%'}</b></div>
        <div class="card"><div class="small">Total DCA PnL</div><b class="${dcaRoi==null?'':(dcaPnl>=0?'ok':'warn')}">${dcaRoi==null?'n/a':'$'+fmt(dcaPnl)}</b></div>
        <div class="card"><div class="small">Total Dip ROI</div><b class="${dipRoi==null?'':(dipRoi>=0?'ok':'warn')}">${dipRoi==null?'n/a':dipRoi.toFixed(2)+'%'}</b></div>
        <div class="card"><div class="small">Total Dip PnL</div><b class="${dipRoi==null?'':(dipPnl>=0?'ok':'warn')}">${dipRoi==null?'n/a':'$'+fmt(dipPnl)}</b></div>
      </div>
      <p class="small" style="margin-top:10px">Mode: <b>${mode}</b>. Asset mode: <b>${assetMode === 'bteth' ? 'BTC+ETH' : 'BTC only'}</b>. Skipped days/entries due to missing price data: ${skipped}. Imported Shakepay buys included: ${useShakepayLots ? ('$'+fmt(shakepayInvested)+' '+quote) : 'off'}.</p>
      ${buildRoiPnlChart(chartSeries)}
      `;
  } catch (e) {
    status.textContent = 'Error: ' + e.message;
  }
};

function parseCsv(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return [];

  const splitCsvLine = (line) =>
    line
      .split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/)
      .map(v => v.trim().replace(/^"|"$/g, '').replace(/""/g, '"'));

  const head = splitCsvLine(lines[0]).map(s=>s.trim().toLowerCase());
  return lines.slice(1).map(line => {
    const cols = splitCsvLine(line);
    const o = {};
    head.forEach((h,i)=> o[h]= (cols[i]||'').trim());
    return o;
  });
}

function num(v){
  if (v == null) return 0;
  const cleaned = String(v).replace(/[$,\s]/g,'');
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : 0;
}

function normalizeShakepayRow(r){
  return {
    date: (r['date'] || '').trim(),
    amountDebited: num(r['amount debited']),
    assetDebited: (r['asset debited'] || '').trim().toUpperCase(),
    amountCredited: num(r['amount credited']),
    assetCredited: (r['asset credited'] || '').trim().toUpperCase(),
    marketValue: num(r['market value']),
    marketValueCurrency: (r['market value currency'] || '').trim().toUpperCase(),
    bookCost: num(r['book cost']),
    bookCostCurrency: (r['book cost currency'] || '').trim().toUpperCase(),
    type: (r['type'] || '').trim(),
    spotRate: num(r['spot rate']),
    buySellRate: num(r['buy / sell rate']),
    description: (r['description'] || '').trim() || '(Unlabeled)'
  };
}

$('analyzeShakepay').onclick = async () => {
  try {
    const file = $('shakepayFile').files[0];
    let text = '';
    if (file) text = await file.text();
    else text = localStorage.getItem('btc.shakepayCsvText') || '';
    if (!text) throw new Error('Pick your Shakepay CSV first.');
    localStorage.setItem('btc.shakepayCsvText', text);
    const rows = parseCsv(text).map(normalizeShakepayRow);
    if (!rows.length) throw new Error('No rows found in Shakepay file.');

    const mode = getAssetMode();
    const quote = getQuoteMode();
    const assets = mode === 'bteth' ? ['BTC','ETH'] : ['BTC'];

    const assetRows = rows.filter(r => assets.includes(r.assetCredited) || assets.includes(r.assetDebited));
    if (!assetRows.length) throw new Error(`No ${assets.join('/')} activity rows found.`);

    const sentRows = rows.filter(r => assets.includes(r.assetDebited));

    const dates = assetRows.map(r => r.date).filter(Boolean).sort();
    const start = dates[0] || 'n/a';
    const end = dates[dates.length-1] || 'n/a';

    let buyCad = 0;
    let buyUnits = 0;
    let buyBtcUnits = 0;
    let buyEthUnits = 0;
    const parsedBuyLots = [];
    let rewardUnits = 0;
    let rewardBtcUnits = 0;
    let recvUnits = 0;
    let sentUnits = 0;
    let recvBtcUnits = 0, recvEthUnits = 0;
    let sentBtcUnits = 0, sentEthUnits = 0;
    let sellBtcUnits = 0, sellEthUnits = 0, sellProceeds = 0;

    const rewardByDesc = {};

    for (const r of assetRows) {
      const type = r.type.toLowerCase();
      const date = (r.date || '').slice(0,10);
      const qty = r.amountCredited || 0;
      const sats = r.assetCredited === 'BTC' ? Math.round(qty * SATS) : 0;

      if (type === 'reward') {
        rewardUnits += qty;
        if ((r.assetCredited||'').toUpperCase() === 'BTC') {
          rewardBtcUnits += qty;
          rewardByDesc[r.description] = (rewardByDesc[r.description] || 0) + sats;
        }
      } else if (type === 'receive') {
        recvUnits += qty;
        if ((r.assetCredited||'').toUpperCase() === 'BTC') recvBtcUnits += qty;
        if ((r.assetCredited||'').toUpperCase() === 'ETH') recvEthUnits += qty;
      } else if (type === 'sell') {
        const proceeds = r.bookCost > 0 ? r.bookCost : r.marketValue;
        const proceedsCcy = (r.bookCostCurrency || r.marketValueCurrency || 'CAD').toUpperCase();
        const proceedsInQuote = convertAmount(proceeds, proceedsCcy, quote, Number($('fx').value||1.35));
        const soldAsset = (r.assetDebited || '').toUpperCase();
        const soldQty = r.amountDebited || 0;
        sellProceeds += proceedsInQuote;
        if (soldAsset === 'BTC') sellBtcUnits += soldQty;
        if (soldAsset === 'ETH') sellEthUnits += soldQty;
      } else {
        const isCostBearingBtcAcquisition = assets.includes((r.assetCredited || '').toUpperCase()) && (type === 'buy' || type === 'convert' || type === 'other') && ((r.bookCost > 0) || (r.marketValue > 0));
        if (isCostBearingBtcAcquisition) {
          const amount = r.bookCost > 0 ? r.bookCost : r.marketValue;
          const amountCcy = (r.bookCostCurrency || r.marketValueCurrency || 'CAD').toUpperCase();
          const amountInQuote = convertAmount(amount, amountCcy, quote, Number($('fx').value||1.35));
          const price = r.buySellRate > 0 ? r.buySellRate : (r.spotRate > 0 ? r.spotRate : null);
          if (date && amount > 0) parsedBuyLots.push({date, amount, ccy: amountCcy, btc: qty || 0, asset: r.assetCredited || 'BTC', price: price || null});
          if (amount > 0) {
            buyCad += amountInQuote;
            buyUnits += qty;
            if ((r.assetCredited||'').toUpperCase() === 'BTC') buyBtcUnits += qty;
            if ((r.assetCredited||'').toUpperCase() === 'ETH') buyEthUnits += qty;
          }
        }
      }
    }

    sentUnits = sentRows.reduce((sum, r) => sum + (r.amountDebited || 0), 0);
    sentBtcUnits = sentRows.filter(r => (r.assetDebited||'').toUpperCase()==='BTC').reduce((sum,r)=>sum+(r.amountDebited||0),0);
    sentEthUnits = sentRows.filter(r => (r.assetDebited||'').toUpperCase()==='ETH').reduce((sum,r)=>sum+(r.amountDebited||0),0);

    shakepayBuyLots.splice(0, shakepayBuyLots.length, ...parsedBuyLots);
    localStorage.setItem('btc.shakepayBuyLots', JSON.stringify(shakepayBuyLots));
    localStorage.setItem('btc.sellBtcUnits', String(sellBtcUnits));
    localStorage.setItem('btc.sellEthUnits', String(sellEthUnits));
    localStorage.setItem('btc.sellProceeds', String(sellProceeds));

    let rewardsFiatToday = null;
    try {
      const qRows = await fetchCC(quote, 10, 'BTC');
      const qMap = toDailyMapCC(qRows, 1);
      const qNow = priceForDate(qMap, new Date());
      if (qNow) rewardsFiatToday = rewardBtcUnits * qNow;
    } catch {}

    save(); render();

    const rewardRows = Object.entries(rewardByDesc)
      .sort((a,b)=>b[1]-a[1])
      .map(([k,v])=>`<tr><td>${esc(k)}</td><td>${Number(v).toLocaleString()}</td><td>${(v/SATS).toFixed(8)} BTC</td></tr>`)
      .join('');

    $('shakepayResult').innerHTML = `
      <p class="ok"><b>Shakepay import complete.</b></p>
      <div class="cards" style="margin-top:8px">
        <div class="card"><div class="small">Date range (${esc(assets.join('/'))} rows)</div><b>${esc(start)} ‚Üí ${esc(end)}</b></div>
        <div class="card"><div class="small">${esc(assets.join('/'))} buy rows parsed from file</div><b>${parsedBuyLots.length}</b></div>
        <div class="card"><div class="small">Total buy ${quote} (all selected assets)</div><b>$${fmt(buyCad)}</b></div>
        <div class="card"><div class="small">BTC units credited</div><b>${buyBtcUnits.toFixed(8)} BTC</b></div>
      </div>
      <div class="cards" style="margin-top:10px">
        <div class="card"><div class="small">ETH units credited</div><b>${buyEthUnits.toFixed(8)} ETH</b></div>
      </div>
      <div class="card" style="margin-top:10px">
        <div class="small">Shakepay Rewards Breakdown (BTC)</div>
        <p><b>Total rewards (BTC):</b> ${rewardBtcUnits.toFixed(8)} (${Math.round(rewardBtcUnits*SATS).toLocaleString()} sats)${rewardsFiatToday!=null ? ` ‚âà <b>$${fmt(rewardsFiatToday)} ${quote}</b> today` : ''}</p>
        ${rewardRows ? `<table><thead><tr><th>Reward source</th><th>Sats</th><th>BTC</th></tr></thead><tbody>${rewardRows}</tbody></table>` : '<p class="small">No reward rows found.</p>'}
      </div>
    `;

    const netBtcFlow = buyBtcUnits + rewardBtcUnits + recvBtcUnits - sentBtcUnits - sellBtcUnits;
    const netEthFlow = buyEthUnits + recvEthUnits - sentEthUnits - sellEthUnits;
    $('flowResult').innerHTML = `
      <div class="cards">
        <div class="card"><div class="small">BTC Bought</div><b>${buyBtcUnits.toFixed(8)} BTC</b></div>
        <div class="card"><div class="small">BTC Rewards</div><b>${rewardBtcUnits.toFixed(8)} BTC</b></div>
        <div class="card"><div class="small">BTC Received</div><b>${recvBtcUnits.toFixed(8)} BTC</b></div>
        <div class="card"><div class="small">BTC Sent</div><b>${sentBtcUnits.toFixed(8)} BTC</b></div>
        <div class="card"><div class="small">BTC Sold</div><b>${sellBtcUnits.toFixed(8)} BTC</b></div>
      </div>
      <div class="card" style="margin-top:10px"><div class="small">Net BTC Flow</div><b>${netBtcFlow.toFixed(8)} BTC</b></div>
      ${mode === 'bteth' ? `<div class="cards" style="margin-top:10px"><div class="card"><div class="small">ETH Bought</div><b>${buyEthUnits.toFixed(8)} ETH</b></div><div class="card"><div class="small">ETH Received</div><b>${recvEthUnits.toFixed(8)} ETH</b></div><div class="card"><div class="small">ETH Sent</div><b>${sentEthUnits.toFixed(8)} ETH</b></div><div class="card"><div class="small">ETH Sold</div><b>${sellEthUnits.toFixed(8)} ETH</b></div><div class="card"><div class="small">Net ETH Flow</div><b>${netEthFlow.toFixed(8)} ETH</b></div></div>` : ''}
      <p class="small" style="margin-top:8px">Use this as a reconciliation helper against your exchange balance snapshot date. Sale PnL uses a simplified model (sale proceeds only); exact realized gains depend on lot method (FIFO/LIFO/HIFO) and off-exchange transfers.</p>
    `;

    // Auto-calculate once right after successful import/analyze
    $('calc').click();
  } catch (e) {
    $('shakepayResult').innerHTML = `<p class="small warn">${esc(e.message)}</p>`;
    $('flowResult').innerHTML = '';
  }
};

render();
</script>
</body>
</html>